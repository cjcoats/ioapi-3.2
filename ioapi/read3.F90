
LOGICAL FUNCTION READ3( FNAME, VNAME, LAYER, JDATE,JTIME, BUFFER)

    !***********************************************************************
    ! Version "$Id: read3.F90 203 2021-10-14 18:02:11Z coats $"
    ! EDSS/Models-3 I/O API.
    ! Copyright (C) 1992-2002 MCNC and Carlie J. Coats, Jr.,
    ! (C) 2003-2013 Baron Advanced Meteorological Systems,
    ! (C) 2007-2013,2021 Carlie J. Coats, Jr., and
    ! (C) 2014-2015 UNC Institute for the Environment.
    ! Distributed under the GNU LESSER GENERAL PUBLIC LICENSE version 2.1
    ! See file "LGPL.txt" for conditions of use.
    !.........................................................................
    !  function body starts at line  138
    !
    !  FUNCTION:
    !       reads data from Models-3 data file with logical name FNAME for
    !       variable with name VNAME and layer LAYER, for the date and time
    !       JDATE (coded YYYYDDD) and time JTIME (HHMMSS).
    !
    !       For time-independent files, JDATE:JTIME are ignored.
    !
    !       If VNAME is 'ALL', reads all variables; if LAYER is -1,
    !       reads all layers.
    !
    !       If FNAME is a dictionary file, READ3() treats VNAME as a
    !       dictionary index, and returns  RDDICT3( FNAME, VNAME ).
    !
    !  RETURN VALUE
    !       TRUE iff the operation succeeds (and the data is available)
    !
    !  PRECONDITIONS REQUIRED:
    !       FNAME is a Models-3 data file already opened by OPEN3()
    !
    !  REVISION  HISTORY:
    !       prototype 3/1992 by CJC
    !
    !       Modified  7/1994 by CJC to handle restart files (tstep < 0)
    !
    !       Modified  8/1994 by CJC to handle BUFFERED "files", and pass
    !       VID argument to new RD*() routines (instead of VNAME)
    !
    !       Modified 10/1994 by CJC to handle new files with write granularity
    !       at the level of individual variables.
    !
    !       Modified  2/1995 by CJC to handle files of type SMATRX3
    !
    !       Modified  2/1995 by CJC to handle files of type TSRIES3
    !
    !       Modified  5/1998 by CJC for OpenMP thread-safety
    !
    !       Modified  5/1999 by ALT for coupling-mode operation
    !
    !       Modified  1/2002 by CJC:  check TRIMLEN() of FNAME
    !
    !       Modified  3/2002 by CJC:  STATE3V changes; uses RDTFLAG().
    !
    !       Modified 7/2003 by CJC:  bugfix -- clean up critical sections
    !       associated with INIT3()
    !
    !       Modified 10/2003 by CJC for I/O API version 3:  support for
    !       native-binary BINFIL3 file type; uses INTEGER NAME2FID
    !
    !       Modified 9/2004 by CJC for virtual INTERP bug-fix: change to
    !       READ3V interface
    !
    !       Modified 11/2004 by CJC:  remove "timestep-not-available"
    !       message (now redundant:  generated by RDTFLAG())
    !
    !       Modified 11/2004 by CJC:  new "verbose-flag" argument to RDTFLAG
    !
    !       Modified 03/2010 by CJC: F9x changes for I/O API v3.1
    !
    !       Modified 08/2015 by CJC: USE MODNCFIO, NF_*() for I/O API v3.2
    !       Support for MPI/PnetCDF files.
    !
    !       Version  10/2021 by CJC:  free ".f90" source format for IOAPI-4.0
    !***********************************************************************

    USE MODNCFIO

    IMPLICIT NONE

    !...........   INCLUDES:

    INCLUDE 'PARMS3.EXT'
    INCLUDE 'STATE3.EXT'
#ifdef IOAPICPL
    INCLUDE 'STATE3V.EXT'
#endif


    !...........   ARGUMENTS and their descriptions:

    CHARACTER*(*), INTENT(IN   ) :: FNAME           !  logical file name
    CHARACTER*(*), INTENT(IN   ) :: VNAME           !  variable name, or 'ALL'
    INTEGER      , INTENT(IN   ) :: LAYER           !  layer number, or 0
    INTEGER      , INTENT(IN   ) :: JDATE           !  date, formatted YYYYDDD
    INTEGER      , INTENT(IN   ) :: JTIME           !  time, formatted HHMMSS
    REAL         , INTENT(  OUT) :: BUFFER(*)       !  input buffer array


    !...........   EXTERNAL FUNCTIONS and their descriptions:

    INTEGER, EXTERNAL :: INDEX1
    INTEGER, EXTERNAL :: NAME2FID   !  fname~~> fid lookup
    LOGICAL, EXTERNAL :: RDDICT3    !  read records for    DCTNRY3  files
    LOGICAL, EXTERNAL :: RDBUF3     !  read time steps for BUFFERED files
    LOGICAL, EXTERNAL :: RDCUSTOM   !  read time steps for CUSTOM3  files
    LOGICAL, EXTERNAL :: RDGRDDED   !  read time steps for GRDDED3  files
    LOGICAL, EXTERNAL :: RDBNDARY   !  read time steps for BNDARY3  files
    LOGICAL, EXTERNAL :: RDIDDATA   !  read time steps for IDDATA3  files
    LOGICAL, EXTERNAL :: RDPROFIL   !  read time steps for PROFIL3  files
    LOGICAL, EXTERNAL :: RDGRNEST   !  read time steps for GRNEST3  files
    LOGICAL, EXTERNAL :: RDSMATRX   !  read time steps for SMATRX33  files
    LOGICAL, EXTERNAL :: RDTFLAG    !  check time step record availability
    EXTERNAL          :: INITBLK3   !  block data: initialize I/O state


    !...........   SCRATCH LOCAL VARIABLES and their descriptions:

    INTEGER         FID             !  subscript  for STATE3 arrays
    INTEGER         VID, VAR        !  subscripts for STATE3 arrays
    INTEGER         FLEN, VLEN      !  name lengths for file, vble
    INTEGER         V               !  loop counters
    INTEGER         STEP, IOFF      !  record number
    CHARACTER*256   MESG
    LOGICAL         EFLAG

#ifdef IOAPICPL
    INTEGER       COUNT, SKIP, TYPE
    INTEGER       F1, F2
    LOGICAL       VFLAG
    LOGICAL, EXTERNAL :: READ3V
#endif

    !***********************************************************************
    !   begin body of function  READ3
    !......,....   Check that Models-3 I/O has been initialized; get STATE3
    !......,....   subscript for FNAME; check length of vname argument

    FLEN  = LEN_TRIM( FNAME )
    VLEN  = LEN_TRIM( VNAME )
    FID   = NAME2FID( FNAME )

    EFLAG = ( FID .LE. 0 )

    IF ( VLEN .GT. NAMLEN3 ) THEN
        EFLAG = .TRUE.
        WRITE( MESG, '( A, I10 )'  ) 'Max vble name length 16; actual:', VLEN
        CALL M3MSG2( MESG )
    END IF          !  if len( vname ) > 16

    IF ( EFLAG ) THEN
        MESG  = 'File "'// FNAME// '" Variable "'// VNAME//'"'
        CALL M3MSG2( MESG )
        MESG = 'Invalid variable or file name arguments'
        CALL M3WARN( 'READ3', JDATE, JTIME, MESG )
        READ3 = .FALSE.
        RETURN
    END IF          !  if len( fname ) > 16, or if len( vname ) > 16

    !.......   Check availability of requested  layer, variable:

    IF ( FTYPE3( FID ) .EQ. DCTNRY3 ) THEN

        READ3 = RDDICT3( FID, VNAME )
        RETURN

    ELSE IF ( VNAME .EQ. ALLVAR3 ) THEN

        VID = ALLAYS3

    ELSE

        VID = INDEX1 ( VNAME, NVARS3( FID ), VLIST3( 1,FID ) )

        IF ( VID .EQ. 0 ) THEN
            MESG = 'File ' // FNAME( 1:FLEN ) //' contains vbles'
            CALL M3MSG2( MESG )
            DO  VAR=1,NVARS3( FID ), 3
                WRITE( MESG,91040 ) (VLIST3( V,FID ),V=VAR,MIN( VAR+2, NVARS3( FID ) ) )
                CALL M3MSG2( MESG )
            END DO
            MESG = 'Requested variable "' //  VNAME( 1: VLEN ) // '" not available'
            CALL M3WARN( 'READ3', JDATE, JTIME, MESG )
            READ3 = .FALSE.
            RETURN
        END IF

    END IF          !  end check on VNAME

    IF ( ( LAYER .NE. ALLAYS3 )         &
        .AND. ( LAYER .LT. 1  .OR.      &
                LAYER .GT. NLAYS3( FID ) ) ) THEN

        WRITE( MESG,91010 ) 'Requested layer:', LAYER
        CALL M3MSG2( MESG )
        WRITE( MESG,91010 ) 'Layers in the file:  1 ...', NLAYS3( FID )
        CALL M3MSG2( MESG )
        MESG = 'LAYER not available in file ' // FNAME
        CALL M3WARN( 'READ3', JDATE, JTIME, MESG )
        READ3 = .FALSE.
        RETURN

    END IF          !  end check on layer-number


    !.......   If buffered file, use RDBUF3():

    IF ( CDFID3( FID ) .EQ. BUFFIL3 ) THEN     !  BUFFERED "file"

        READ3 = RDBUF3( FID, VID, LAYER, JDATE, JTIME, BUFFER )
        RETURN

#ifdef IOAPICPL

    !.......   If virtual file, use READ3V():

    ELSE IF ( CDFID3( FID ) .EQ. VIRFIL3 ) THEN     !  virtual "file"

        IF ( TSTEP3( FID ) .NE. 0 ) THEN
            F1    = JDATE
            F2    = JTIME
        ELSE
            F1    = 0
            F2    = 0
        END IF

        IF ( LAYER .EQ. ALLAYS3 ) THEN
            COUNT = BSIZE3(FID)*NLAYS3(FID)
            SKIP = 0
        ELSE
            COUNT = BSIZE3(FID)
            SKIP = (LAYER - 1) * BSIZE3(FID)
        ENDIF

        IF ( VID .EQ. ALLAYS3 ) THEN
            EFLAG = .TRUE.
            DO VID = 1, NVARS3(FID)
                IOFF  = 1 + ( VID-1 )*BSIZE3(FID)*NLAYS3(FID)
                VFLAG = READ3V( FID, VID, SKIP, COUNT, F1, F2, BUFFER(IOFF) )
                EFLAG = ( EFLAG .AND. VFLAG )
            END DO
            READ3 = EFLAG
        ELSE
            TYPE  = VTYPE3(VID,FID)
            READ3 = READ3V( FID, VID, SKIP, COUNT, F1, F2, BUFFER )
        END IF

        RETURN

#endif

    END IF                  !  if buffered, or virtual, or volatile


    !...........   Compute record number, and check availability:
    !...........   Note:  rdtflag() calls NF_SYNC()

    IF ( .NOT. RDTFLAG( FID,VID, JDATE,JTIME, STEP, .TRUE. ) ) THEN

    !! warning now generated by RDTFLAG():
    !! MESG = 'Time step not available for file:  ' // FNAME
    !! CALL M3WARN( 'READ3', JDATE, JTIME, MESG )
        READ3 = .FALSE.
        RETURN

    END IF


    !...........   Read data from file into BUFFER()

    IF ( FTYPE3( FID ) .EQ. CUSTOM3 ) THEN

        READ3 = RDCUSTOM( FID, VID, LAYER, STEP, BUFFER )

    ELSE IF ( FTYPE3( FID ) .EQ. GRDDED3 ) THEN

        READ3 = RDGRDDED( FID, VID, LAYER, STEP, BUFFER )

    ELSE IF ( FTYPE3( FID ) .EQ. MPIGRD3 ) THEN

        READ3 = RDGRDDED( FID, VID, LAYER, STEP, BUFFER )

    ELSE IF ( FTYPE3( FID ) .EQ. BNDARY3 ) THEN

        READ3 = RDBNDARY( FID, VID, LAYER, STEP, BUFFER )

    ELSE IF ( FTYPE3( FID ) .EQ. IDDATA3 ) THEN

        READ3 = RDIDDATA( FID, VID, LAYER, STEP, BUFFER )

    ELSE IF ( FTYPE3( FID ) .EQ. PROFIL3 ) THEN

        READ3 = RDPROFIL( FID, VID, LAYER, STEP, BUFFER )

    ELSE IF ( FTYPE3( FID ) .EQ. GRNEST3 ) THEN

        READ3 = RDGRNEST( FID, VID, LAYER, STEP, BUFFER )

    ELSE IF ( FTYPE3( FID ) .EQ. SMATRX3 ) THEN

        READ3 = RDSMATRX( FID, VID, STEP, BUFFER )

    ELSE IF ( FTYPE3( FID ) .EQ. TSRIES3 ) THEN

        READ3 = RDGRDDED( FID, VID, LAYER, STEP, BUFFER )

    ELSE IF ( FTYPE3( FID ) .EQ. PTRFLY3 ) THEN

        READ3 = RDGRDDED( FID, VID, LAYER, STEP, BUFFER )

    ELSE    !  illegal file type

        WRITE( MESG, "( 3A, I5 )" ) 'File:  ', FNAME( 1:FLEN ), ' of unknown type:', FTYPE3( FID )
        CALL M3WARN( 'READ3', JDATE, JTIME, MESG )
        READ3 = .FALSE.

    END IF          !  if file type dictionary, custom, gridded, ...


    RETURN

    !******************  FORMAT  STATEMENTS   ******************************

    !...........   Error and warning message formats..... 91xxx

91010 FORMAT ( 3 ( A , :, I5, :, 2X ) )

91040 FORMAT ( 3 ( '"', A16, '"', :, 4X ) )

END FUNCTION READ3



<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">

<HTML> 
<HEAD>
<!-- "$Id: WRF_IOAPI.html 183 2015-04-15 19:04:15Z coats $" -->
<META NAME="MSSmartTagsPreventParsing" CONTENT="TRUE"> 
<TITLE> 
    DRAFT: WRF/Models-3/EDSS I/O&nbsp;API
</TITLE>
</HEAD>
   
<BODY BGCOLOR="#FFFFFF" 
      TOPMARGIN   ="15" 
      MARGINHEIGHT="15" 
      LEFTMARGIN  ="15" 
      MARGINWIDTH ="15">

<CENTER>
<H1>
    <STRONG>DRAFT</STRONG><BR>
    Layering the WRF I/O&nbsp;API <BR>
    on Top of the <BR>
    Models-3/EDSS I/O&nbsp;API
</H1>

<H3>
    Carlie J. Coats, Jr.<BR>
    MCNC Environmental Modeling Center<BR>
    <EM> <A HREF = "mailto:cjcoats@email.unc.edu">
    cjcoats@email.unc.edu</A></EM>
</H3>

</CENTER>

    <!-- There are no tyops in this web page. -->

<H2>
    <A NAME="contents">Contents</A>
</H2>

    <UL>
        <LI>  <A HREF="#intro">
              Introduction</A>

        <LI>  <A HREF="#defs">
              Dataset Definition Issues</A>

        <LI>  <A HREF="#dist">Field I/O and Data Distribution Issues</A>

        <LI>  <A HREF="#date">Date and Time Sequencing Issues</A>

        <LI>  <A HREF="#dict">
              Required-Attribute Dictionary</A>

        <LI>  <A HREF="#addl">
              Additional Requirements for the WRF I/O&nbsp;API</A>

        <LI>  <A HREF="#sugn">
              Suggestions for Enhancing the WRF I/O&nbsp;API</A>

        <LI>  <A HREF="#m4io">
              M4IO:  Enhancements to the Models-3 I/O&nbsp;API</A>

        <LI>  <A HREF="#wish">
              WRF Implementation Wishlist</A>

        <LI>  <A HREF="#impl">
              Layered WRFIO/M3IO Implementation Strategy</A>

        <LI>  <A HREF="#refs">
              References</A>
    </UL>

<HR> <!----------------------------------------------------------------->

<H2>
    <A NAME="intro">Introduction</A>
</H2>


    <BLOCKQUOTE>
    The exercise of &quot;wrapperizing&quot; the Models-3/EDSS
    I/O&nbsp;API (M3IO) within the WRF I/O&nbsp;API (WRFIO) is
    dominated by just a few issues:

    <UL>
        <LI>  different approaches to dataset/variable/metadata definition,
        <LI>  data distribution issues
        <LI>  date&time sequencing assumptions
        <LI>  similar/compatible approaches to field I/O (albeit with
              somewhat different allocation of responsibility for
              gather/scatter)
        <LI>  minor data structure differences
    </UL>
    These issues are quite resolvable. This paper gives a suggested
    implementation of the M3IO external I/O package within WRFIO, along
    with the metadata dictionary needed by the WRF
    &quot;configure/build&quot; system, additional requirements that
    this places on WRFIO, thoughts for an enhanced M3IO, and suggestions
    for augmenting WRFIO.
    <P>

    The current plan is a two-stage one:
    <OL>
        <LI>  to construct a restricted prototype WRFIO
              <CODE>ext_m3io</CODE> package on top of a minimally
              modified version of M3IO, for use with the Summer&nbsp;2002
              air quality forecast effort; and
              <P>
        <LI>  to construct an enhanced version of the Models-3/EDSS
              I/O&nbsp;API (M4IO), together with a full-function WRFIO
              <CODE>ext_m4io</CODE> package built on top of it.
    </OL><P>
    As this document is being written, the effort to implement (1)
    is underway.  This effort is bearing fruit in terms of finding
    &quot;holes&quot;, ambiguities, and other difficulties in the WRFIO
    specification.
    <P>

    </BLOCKQUOTE>
    <A HREF="#contents"><STRONG>Back to <EM>Contents</EM></STRONG></A>
    <P>

<HR> <!----------------------------------------------------------------->
<H2>
    <A NAME="defs">Dataset Definition Issues</A>
</H2>

    <BLOCKQUOTE>
    M3IO takes the point of view that the API should encapsulate state
    to the greatest degree possible, and avoid shared state between
    itself and its callers.  For example, a dataset must be defined
    in one atomic operation, in which the user fills in all the fields
    in a dataset definition and then calls the <CODE>OPEN3()</CODE>
    routine.  Similarly, to get a file's metadata, one makes a single
    <CODE>DESC3()</CODE> call and is returned the complete description
    of a dataset, together with all its metadata.  As is appropriate
    for providing the level of commonality and integrity required of
    an API used for multi-model environmental modeling applications,
    for model coupling, and for easy callability from legacy Fortran-77
    applications, the set of metadata required is fixed by a
    proscriptive standard; it is an error not to supply the complete
    set of metadata needed by <CODE>OPEN3()</CODE> during data set
    creation.  
    <P>

    On the other hand, the WRFIO paradigm is to supply tools that allow
    the definition of an open-ended set of metadata, at the modeler's
    discretion, but with the added complication of considerable shared
    state between WRFIO and its callers.  The
    <CODE>ext_<VAR>pkg</VAR>_get|put*()</CODE> routines in WRFIO allow
    the user to define a dataset incrementally by means of repeated calls.
    Provided that the &quot;configure/build&quot; system can ensure
    that all of the definitions expected by the M3IO are made (between
    calls to  <CODE>ext_<VAR>pkg</VAR>_open_for_write_begin()</CODE>
    and <CODE>ext_<VAR>pkg</VAR>_open_for_write()</CODE>), there would
    seem to be no conceptual difficulty in wrapperizing M3IO within
    WRFIO.  A complete dictionary of the metadata which must be set in
    order to completely define an M3IO-implemented data set is given
    in the section below, <EM><A HREF="#dict">Required-Attribute
    Dictionary</A>.</EM> <BR>
    <STRONG>Ensuring that the &quot;configure/build&quot; system
    generates all the required definitions and metadata attributions
    during data set creation is a fundamental constraint of this
    &quot;wrapperizing&quot; approach.</STRONG>
    <P>

    One problem with this open-ended operational paradigm is the
    lack of routines&nbsp;--&nbsp;within both WRFIO and M3IO as they
    presently exist&nbsp;--&nbsp;for inquiring about the existence,
    names, and types of metadata that have been stored in a WRF data
    set, as we describe in the section, <EM><A HREF="#addl">Additional
    Requirements</A></EM>, below.
    <P>

    A minor implementation issue is that M3IO only supports input and
    output of fields of types <CODE>INTEGER</CODE>, <CODE>REAL</CODE>,
    and <CODE>REAL8</CODE>, whereas WRF also has fields of type
    <CODE>LOGICAL</CODE>.  It will be very simple to add support for
    the additional <CODE>LOGICAL</CODE> type required by WRF, and it
    has recently become understood how to add the
    <CODE>CHARACTER(LEN=&lt;n&gt;</CODE> types requested by EPA for
    emissions and observational data.  Changes for these new types 
    not will break backwards data, source, nor link compatibility of
    M3IO.
    <P>
    
    A larger issue is what to do with attributes not expected by
    M3IO (which has a fixed list of what attributes it expects, as
    documented below in the section <EM><A HREF="#dict">Required 
    Attribute Dictionary</A></EM> ); we
    conclude that the wrapper should go ahead and read or write these
    attributes at the raw netCDF (or PVM or other) lower I/O level, so
    that the resulting data sets are &quot;M3IO-plus&quot;, with
    additional metadata not maintained by the M3IO proper.  (Due to the
    selective direct access nature of the underlying netCDF and PVM
    M3IO-implementation layers, the existence of additional attributes
    not accessed by the existing system is irrelevant to that system.) 
    This WRF requirement implied by the open-ended set of &quot;put
    attribute calls could lead to an augmentation of the existing M3IO,
    for the creation, inquiry, and access to additional metadata within
    M3IO datasets (probably the cleanest way to implement this WRF
    requirement).  This issue,as well as the previous type extension
    issue, is discussed further below in the section, <EM><A
    HREF="#m4io"> Enhancements to the Models-3 I/O&nbsp;API</A>.</EM> 
    <P>

    Another issue that does come up is the issue of time-dependent
    metadata, implied by the <CODE>ext_<VAR>pkg</VAR>_put_*_td_type()</CODE>
    routines:  netCDF does not have provisions for implementing time
    dependent metadata, and consequently neither does M3IO.  Presently,
    these are not used by the WRF model itself, and the draft document
    indicates &quot;not yet implemented&quot;.  One way to implement
    these is as by auxilliary variables in the data set; doing so puts
    some additional constraints on WRFIO, as we describe below in the
    section, <EM><A HREF="#addl">Additional Requirements</A>.</EM>
    <P>

    A final issue is the issue of WRF
    &quot;stagger&quot;&nbsp;--&nbsp;for M3IO files, all variables have
    the same grid structure, so that (for an MM5/MAQSIP example), the
    dot point variables (for which WRF stagger is
    <CODE>&quot;XY&quot;</CODE>) inhabit different files from the cross
    point variables(for which WRF stagger is none, coded
    <CODE>&quot;-&quot;</CODE>).  The three obvious potential solutions
    to this problem are (1)&nbsp;to extend M3IO to support stagger;
    (2)&nbsp;to dimension files to the extent of
    <CODE>&quot;XY&quot;</CODE> stagger, pad all output variables out
    to the extent of those dimensions (and subset on input), and to add
    extra per-variable attributes describing the stagger-padding,
    Z-staggered variables being written both to the 2-D and the 3-D
    M3IO data sets that represent a particular WRFIO data set; or
    (3)&nbsp;to let a WRFIO data set be implemented by multiple files,
    one for each stagger type.  We recommend alternative&nbsp;(1)
    below, in the section, <EM><A HREF="#m4io"> Enhancements to the
    Models-3 I/O&nbsp;API</A>.</EM>
    <P>
    
    <EM>Due to the difficulties of maintaining the data structures
    necessary to store some indefinite number of additional
    non-standard metadata of multiple unknown types and sizes,
    <STRONG>the initial M3IO implementation of WRFIO to be used for the
    Summer&nbsp;2002 air quality forecasting will not support any metadata
    except per-variable stagger and those metadata already standard for
    M3IO.</STRONG></EM>
    <P>

    </BLOCKQUOTE>
    <A HREF="#contents"><STRONG>Back to <EM>Contents</EM></STRONG></A>
    <P>

<HR> <!----------------------------------------------------------------->
<H2>
    <A NAME="dist">Field I/O and Data Distribution Issues</A>
</H2>

    <BLOCKQUOTE>
    The WRFIO <CODE>ext_<VAR>pkg</VAR>_read|write_field()</CODE> calls
    map fairly cleanly to M3IO <CODE>READ3()</CODE> and
    <CODE>WRITE3()</CODE> calls -- the biggest difference being the
    domain and patch dimensionality and stagger info contained in the
    calls, and the added per-level optional selectivity offered by
    the M3IO <CODE>READ3()</CODE>.  The WRFIO notions of &quot;output
    frames&quot; and  <CODE>ext_<VAR>pkg</VAR>_get_next_var()</CODE>
    (etc.) can easily be implemented by maintaining an internal
    per-dataset state variable that keeps the current-frame simulation
    clock and current variable for the dataset.
    <P>

    Initially, we propose to to support two modes of operation, based
    on data distribution--the modes that do <EM>not</EM> do distributed
    gather/scatter operations within WRFIO, with place-holders in
    place to extend to a third which does implement internal WRFIO
    gather/scatter, as described below.  (As we understand it, this
    restriction is consistent with the current functionalities
    supported by the netCDF implementation, as well.)
    <P>

    <BLOCKQUOTE>
    <DL>
       <DT><EM><STRONG>Question&nbsp;1: </STRONG> 
       <DD>  NetCDF doesn't have a notion of a <CODE>LOGICAL</CODE> 
             type for variables and attributes.  Is this mapped to
             netCDF <CODE>INTEGER</CODE>, , and if so, is this
             guaranteed to be portable? </EM>
             <P>

       <DT><EM><STRONG>Question&nbsp;2: </STRONG> 
       <DD>  What is the role of the <CODE>COM</CODE> argument to
             <CODE>ext_m3io_write_field()</CODE> and
             <CODE>ext_m3io_read_field()</CODE>?  Can it be used to
             distinguish between the non-gather/scatter first and
             second modes, and the (internal gather/scatter)
             third?</EM>
             <P>

        <DT><STRONG>Full-Domain to Full-Domain</STRONG>
        <DD>  In this scenario, full-domain gathers are performed by the
              driver layer prior to calling
              <CODE>ext_m3io_write_field()</CODE> or subsequent to
              <CODE>ext_m3io_read_field()</CODE>.  There is a single
              unified full-domain data set produced.  This case can be
              recognized on the M3IO-package side by the fact that the
              patch-extent arguments are the same as the
              domain-dimension arguments (<EM>and the <CODE>COM</CODE>
              argument is turned off?</EM>).
        <P>

        <DT><STRONG>Distributed to Distributed (same patch
             decompostion)</STRONG>
        <DD> In this scenario, distributed (parallel per-patch)
             calls are made to <CODE>ext_m3io_write_field()</CODE> and
             <CODE>ext_m3io_read_field()</CODE>.  These routines do I/O
             on a distributed data set (i.e., with different files for 
             different patches), already correctly partitioned
             appropriately across the computational nodes, for
             distributed (this-patch) inputs or outputs.  For this
             mode, patch-extent arguments are different from
             domain-dimension arguments (<EM>and the <CODE>COM</CODE>
             argument is turned off?)</EM>.
        <P>

        <DT><STRONG>Distributed to Full-Domain</STRONG>
        <DD> In this scenario, distributed (parallel per-patch)
             calls are made to <CODE>ext_m3io_write_field()</CODE> and
             <CODE>ext_m3io_read_field()</CODE>.  These routines do I/O
             on a full-domain data set and then do gather/scatter
             operations to generate distributed (this-patch) inputs or
             outputs.  <EM>This mode of operation is distinguished by
             the fact that the <CODE>COM</CODE> argument is turned
             on&nbsp;(?)</EM>
        <P>
        <DT><STRONG>Distributed to Distributed (different patch
             decompostions)</STRONG>
        <DD> In this scenario, distributed (parallel per-patch)
             calls are made to <CODE>ext_m3io_write_field()</CODE> and
             <CODE>ext_m3io_read_field()</CODE>.  These routines do I/O
             on a distributed data set (i.e., with different files for 
             different patches), on distributed data sets with patch
             decompositions different from the current WRF patch
             decomposition.  <STRONG>We do not intend to support this
             mode.  Is it necessary to detect it, and flag it as an
             error?</STRONG>).
        <P>

    </DL>
    </BLOCKQUOTE>

    </BLOCKQUOTE>
    <A HREF="#contents"><STRONG>Back to <EM>Contents</EM></STRONG></A>
    <P>

<HR> <!----------------------------------------------------------------->
<H2>
    <A NAME="date">Dates and Times; Sequencing Issues</A>
</H2>

    <BLOCKQUOTE>
    M3IO clock objects use pairs <CODE>INTEGER&nbsp;JDATE,JTIME</CODE>
    to represent time accurate to (exact integer) seconds, using a
    coding of <CODE>YYYYDDD:HHMMSS</CODE>; time steps are exact
    integers coded <CODE>H*MMSS</CODE>.  There is a complete set of
    routines for date and time manipulation; the entire system is robust
    with respect to negative time steps and  &quot;denormalized&quot;
    dates and times such as <CODE>1999476:-234567</CODE> (this
    represents April 19, 2000 at 00:13:53--a date&amp;time 23 hours, 45
    minutes, and 67 seconds before the 476-365=111'th day of the year
    2000).  WRFIO clock objects use <CODE>character(len=??)</CODE>
    strings (of various inconsistent lengths in the documentation) and
    documented as accurate to milliseconds and formatted
    <CODE>YYYY-MM-DD-HH-MM-SS.SSS</CODE>.  What to do if the
    millisecond field for an M3IO implementation of WRFIO is nonzero is
    an open problem; however, it is not unreasonable that for many (or
    even most) applications, the WRF model time step will be an integer
    number of seconds, and this issue can be avoided.  (On the other
    hand, there is a request for an enhanced I/O API that maintains an
    even more accurate notion of clock object, as documented below in
    the section, <EM><A HREF="#m4io"> Enhancements to the Models-3
    I/O&nbsp;API</A>.</EM>  With Fortran-90/95 function overloading,
    one can even make this enhancement transparent to existing
    applications, as a (hidden-by-F90) M3IO extension.  The M3IO direct
    access mode of operation, and hence its deterministic record-number
    requirement can be preserved either by the use of rational-number
    fraction fields, or by double-precision fraction-fields (which have
    sufficient numerical precision that millisecond-level error
    tolerances can be preserved even for very long time step
    sequences).  For the initial M3IO version for the Summer&nbsp;2002 air
    quality forecasting effort, we will require exact-integer time
    steps; for the full M4IO, we will choose one of the enhanced
    formulations.
    <P>

    An issue arises with respect to time-step sequences.  For M3IO,
    time step sequences are characterized by a <STRONG>starting
    date</STRONG>, a <STRONG>starting time</STRONG>, and a <STRONG>time
    step</STRONG>.  The correspondence between elements of a time step
    sequence and &quot;record numbers&quot; is a deterministic one, as
    made possible by the facts that the relevant arithmetic is exact
    integer arithmetic and that the time step is constant for the
    entire time step sequence.  This will create a
    &quot;show-stopper&quot; problem for data sets of high temporal
    resolution, if a WRF driver were constructed to use an adaptive
    time step scheme.  For coarser output time steps (i.e.,
    substantially larger than the solver time-step), we would resort
    to the scheme used by the <CODE>MCPL()</CODE>  output module for
    MM5, to deal with the non-determinism of pre-Version-3 MM5
    time-keeping:  find the model time step that <EM>contains</EM> the
    desired input or output time step, and thereby keeping the temporal
    error at most one model time step (probably good enough for hourly
    input, for example).
    <P>
    
    A special case of this is the case of time-independent data: 
    presently, I can see no means in WRFIO to define that a variable is
    time-independent (at least in the documentation to which I have
    access, nor do I see provision for time independent variables
    implied in what I read of the Registry.  On the other hand, there
    are a number of variables for which it is clearly worthwhile to note
    that they are time independent: <VAR>z</VAR>, <VAR>pb</VAR>,
    <VAR>pb8w</VAR>, <VAR>msft</VAR>, <VAR>msfu</VAR>,
    <VAR>msfv</VAR>, <VAR>f</VAR>, <VAR>e</VAR>, <VAR>sina</VAR>,
    <VAR>cosb</VAR>, <VAR>ht</VAR>, etc.
    <P>

    Another issue is the WRFIO concept of <STRONG>input and output
    frames</STRONG>.  Since M3IO does selective direct access I/O,
    it naturally performs I/O operations when they are requested,
    and the sequential-file &quot;frame&quot; concept is not even
    relevant.  As far as I can tell, however, this is of issue only 
    in terms of requiring that the external M3IO package for WRFIO
    must maintain and update the state variables related to frames
    (<CODE>ext_m3io_end_of_frame(DataHandle,Status)</CODE> must
    increment the specified data set's date&amp;time, for example).
    <P>

    <EM><STRONG>QUESTION: </STRONG> Given the WRFIO concept of a
    &quot;current frame&quot;, (with its own date&amp;time) as
    maintained by routines</EM>
    <CODE>
    ext_<VAR>pkg</VAR>_get_next_time(DataHandle,&nbsp;DateStr,&nbsp;Status),
    ext_<VAR>pkg</VAR>_set_time(DataHandle,&nbsp;DateStr,&nbsp;Status)
    ext_<VAR>pkg</VAR>_end_of_frame(DataHandle,&nbsp;Status)
    </CODE>
    <EM>and</EM>
    <CODE>
    ext_<VAR>pkg</VAR>_get_next_var(DataHandle,&nbsp;VarName,&nbsp;Status)
    </CODE>, <EM> and given that the routines</EM>
    <CODE>
    ext_<VAR>pkg</VAR>_read_field(DataHandle,&nbsp;DateStr,&nbsp;...)
    </CODE>
    <EM>and</EM>
    <CODE>
    ext_<VAR>pkg</VAR>_write_field(DataHandle,&nbsp;DateStr,&nbsp;...)
    </CODE> <EM> have a possibly different </EM><CODE>DateStr</CODE>
    <EM>as one of the arguments, <STRONG>how do these latter two
    routines interact with the current-frame date&amp;time?</STRONG>
    Also, how do the first three (dealing with potentially changing
    the current frame) interact with <CODE>get_next_var</CODE>?
    </EM>
    <P>

    </BLOCKQUOTE>
    <A HREF="#contents"><STRONG>Back to <EM>Contents</EM></STRONG></A>
    <P>

<HR> <!----------------------------------------------------------------->
<H2>
    <A NAME="dict">Required-Attribute Dictionary</A>
</H2>

    <BLOCKQUOTE>
    As a consequence of its single-operation &quot;build a file from a
    complete file-definition&quot; mode of operation, and consistent
    with the integrity requirements for the multi-model nature of
    environmental modeling applications, it is required that during the
    &quot;dry-run&quot; file-creation phase, the WRF execute a set of
    &quot;put-metadata&quot; calls sufficient to complete a MM3IO file
    definition, and specify these metadata by the names recognized by
    the <CODE>external_m3io</CODE> package.  <STRONG>It is an error to
    call <CODE>ext_open_for_write_commit()</CODE> without having
    specified the entire set of metadata for a complete M3IO data set
    definition.</STRONG>
    <P>

    The dictionaries of required &quot;global&quot; and per-variable
    metadata are given below.
    <P>
    </BLOCKQUOTE>

<H3>
    Global Metadata
</H3>

    <EM><STRONG>Constraint:</STRONG> For the initial M3IO implementation
    (for use in the Summer&nbsp;2002 air quality forecasting effort), only
    the M3IO standard global metadata, as documented below, will be
    supported.</EM>
    <P>

    <EM><STRONG>Question:</STRONG> What is the difference between WRFIO
    &quot;global metadata&quot; and &quot;domain metadata&quot;? Both
    have unique per-data-set values, applicable to the entire data
    set...</EM>
    <P>

    The following are global metadata that must be set while the 
    file is still in the definition phase.
    <BLOCKQUOTE>
    <DL>
        <DT> <CODE> DOMAIN_NAME <EM> (character(len&le;32)) </EM> </CODE>
        <DD>  
        <P>

        <DT> <CODE> PROJ_TYPE <EM>(integer)</EM></CODE>
        <DD> Identifier-Token for the horizontal map-projection type, as
             documented at URL <EM><A HREF =
        "/products/ioapi/GRIDS.html#horiz">
        /products/ioapi/GRIDS.html#horiz</A></EM> 
        <UL>
            <LI>  <STRONG>1:</STRONG>  <VAR>Lat-Lon</VAR>
            <LI>  <STRONG>2:</STRONG>  <VAR>Lambert Conformal Conic</VAR>
            <LI>  <STRONG>3:</STRONG>  <VAR>General Tangent Mercator</VAR>
            <LI>  <STRONG>4:</STRONG>  <VAR>General Stereographic</VAR>
            <LI>  <STRONG>5:</STRONG>  <VAR>Universal Transverse Mercator</VAR>
            <LI>  <STRONG>6:</STRONG>  <VAR>Secant Polar Stereographic</VAR>
            <LI>  <STRONG>7:</STRONG>  <VAR>Equatorial Mercator</VAR>
            <LI>  <STRONG>8:</STRONG>  <VAR>General Transverse Mercator</VAR>
        </UL>
        <P>

        <DT> <CODE> PROJ_ALPHA <EM>(real8)</EM></CODE>
        <DD> First defining angle for the map projection, as documented
             in the URL above, in <VAR>degrees</VAR>
        <P>

        <DT> <CODE> PROJ_BETA <EM>(real8)</EM></CODE>
        <DD> Second defining angle for the map projection, as documented
             in the URL above, in <VAR>degrees</VAR>
        <P>

        <DT> <CODE> PROJ_GAMMA <EM>(real8)</EM></CODE>
        <DD> Third defining angle for the map projection, as documented
             in the URL above, in <VAR>degrees</VAR>
        <P>

        <DT> <CODE>PROJ_XCENT <EM>(real8)</EM></CODE>
        <DD> Longitude of the Cartesian origin for the map projection,
             as documented in the URL above, in <VAR>degrees</VAR>
        <P>

        <DT> <CODE>PROJ_YCENT <EM>(real8)</EM></CODE>
        <DD> Latitude of the Cartesian origin for the map projection,
             as documented in the URL above, in <VAR>degrees</VAR>
        <P>

        <DT> <CODE>DOMAIN_XORIG <EM>(real8)</EM></CODE>
        <DD> Cartesian X coordinate for the starting (1,1) corner 
             of the domain, as documented in the URL above, in 
             <VAR>meters</VAR>.
        <P>

        <DT> <CODE>DOMAIN_YORIG <EM>(real8)</EM></CODE>
        <DD>  Cartesian Y coordinate for the starting (1,1) corner 
             of the domain, as documented in the URL above, in 
             <VAR>meters</VAR>.
        <P>

        <DT> <CODE>DOMAIN_XCELL <EM>(real8)</EM></CODE>
        <DD>  Cartesian cell-size in the X direction, as documented in
              the URL above, in  <VAR>meters</VAR>.
        <P>

        <DT> <CODE>DOMAIN_YCELL <EM>(real8)</EM></CODE>
        <DD>  Cartesian cell-size in the Y direction, as documented in
              the URL above, in  <VAR>meters</VAR>.
        <P>

        <DT> <CODE>DOMAIN_NCOLS <EM>(integer)</EM></CODE>
        <DD> Number of dot point columns in the domain
        <P>

        <DT> <CODE>DOMAIN_NROWS <EM>(integer)</EM></CODE>
        <DD>  Number of dot point rows in the domain
        <P>

        <DT> <CODE>DOMAIN_NTHIK <EM>(integer)</EM></CODE>
        <DD> Boundary thickness (# of cells) for the domain; 
             usually +1 for an (unthickened) external boundary,
             or -1 for an internal boundary.
        <P>

        <DT> <CODE>DOMAIN_NLAYS <EM>(integer)</EM></CODE>
        <DD> Number of levels for the domain
        <P>

        <DT> <CODE>DOMAIN_VTYPE <EM>(integer)</EM></CODE>
        <DD> Vertical coordinate type for the domain,  as
             documented at URL <EM><A HREF =
        "/products/ioapi/GRIDS.html#horiz">
        /products/ioapi/GRIDS.html#horiz</A></EM>
        and to be extended for WRF below: 
        <UL>
            <LI>  <STRONG>7,8,...:</STRONG>  <EM>New vertical coordinate
                  types to be defined for WRF</EM>,
                  <A HREF="#vert">as documented below.</A>
            <LI>  <STRONG>1:</STRONG>  Hydrostatic sigma-P (e.g., for MM4,
                  MM5)
            <LI>  <STRONG>2:</STRONG>  Non-hydrostatic sigma-P
            <LI>  <STRONG>3:</STRONG>  Sigma-Z
            <LI>  <STRONG>4:</STRONG>  Pressure <VAR>(Pa)</VAR>
            <LI>  <STRONG>5:</STRONG>  Altitude Z 
                                       <VAR>(M above sea level)</VAR>
            <LI>  <STRONG>6:</STRONG>  Height H 
                                       <VAR>(M above ground level)</VAR>
        </UL>
        <P>

        <DT> <CODE>DOMAIN_VTOP <EM>(real)</EM></CODE>
        <DD> Domain top for sigma coordinates (<VAR>Pa</VAR> for
             Sigma-P, <VAR>M</VAR> for Sigma-Z)
        <P>

        <DT> <CODE>DOMAIN_LEVELS <EM>(real(0:NLAYS)&nbsp;)</EM></CODE>
        <DD> Vertical coordinate values for the level-surfaces
        <EM><STRONG>Constraint</STRONG>:  Prior establishment of 
        <CODE>DOMAIN_NLAYS</CODE> is required.</EM>
        <P>

        <DT> <CODE>START_DATETIME <EM>(character(len=24)&nbsp;)</EM></CODE>
        <DD> starting date and time, given according to WRF conventions
        <P>

        <DT> <CODE>TIME_STEP <EM>(character(len=24)&nbsp;)(?)</EM></CODE>
        <DD> dataset time step, given according to WRF time step
             conventions <EM>(which are TBD?)</EM><BR>
             <EM>NOTE:  to the extent that WRF data sets have both
             time independent and time stepped variables, this will need
             to be a <STRONG>per-variable</STRONG> attribute that must
             either be zero (indicating a time independent variable) or
             have a common value for the entire data set (for the time
             stepped variables)</EM>
        <P>

        <DT> <CODE>PROG_NAME <EM>(character(len=*))</EM></CODE>
        <DD> Name of the program creating the data set.
        <P>

        <DT> <CODE>DATASET_DESC <EM>(character(len&lt;=4800))</EM></CODE>
        <DD> dataset description (think of this as up to 60 lines of
             80 characters each, with NEWLINE=ACHAR(10) as the delimiter)
        <P>

    </DL>
    </BLOCKQUOTE>

    In addition, the M3IO runtime system always automatically maintains
    the following additional metadata, which are available on datasets
    opened for input:

    <BLOCKQUOTE>
    <DL>
        <DT> <CODE>DOMAIN_NVARS_2D <EM>(integer)</EM></CODE>
        <DD> Number of 2-D variables for the domain
        <P>

        <DT> <CODE>DOMAIN_NVARS_3D <EM>(integer)</EM></CODE>
        <DD> Number of 3-D variables for the domain
        <P>

        <DT> <CODE>CREATION_DATETIME <EM>(character(len=24))</EM></CODE>
        <DD> Date and time (GMT) that the dataset was created, given
             according to WRF conventions
        <P>

        <DT> <CODE>UPDATE_DATETIME <EM>(character(len=24))</EM></CODE>
        <DD> Date and time (GMT) that the dataset was last updated, given
             according to WRF conventions
        <P>

        <DT> <CODE>EXECUTION_ID <EM>(character(len=80)&nbsp;)</EM></CODE>
        <DD> Execution-ID for the program execution that created the
             dataset, according to Models-3 conventions.
        <P>

        <DT> <CODE>UPDATE_DESC <EM>(character(len=4800)&nbsp;)</EM></CODE>
        <DD> Run/Execution-description for the program execution that
             created the dataset, according to Models-3 conventions.
        <P>

    </DL>
    </BLOCKQUOTE>

<H3>
    Per-Variable Metadata
</H3>

    <BLOCKQUOTE>

    <EM><STRONG>Constraint 1:</STRONG> For the initial Summer&nbsp;2002 M3IO
    air quality forecast implementation, only <CODE>STAGGER</CODE> and the
    standard M3IO global and per-variable metadata, as documented below,
    will be supported.</EM>
    <P>

    <EM><STRONG>Constraint 2:</STRONG>  The indicated data set must be in 
    define-mode (i.e., dry-run, prior to commit) in order to set these
    metadata.</EM>
    <P>

    <EM><STRONG>Constraint 3:</STRONG>  Before these (or any per-variable)
    metadata are specified, the variable itself must have been registered
    by a prior (dry-run) <CODE>ext_m3io_write_field()</CODE> call.</EM>

    <DL>
        <DT> <CODE>VAR_TSTEP <EM>(character(len=24)&nbsp;)</EM></CODE>
        <DD> Time step specification for the indicated variable.  Must
        either be 0 (indicating that the variable is time independent,
        or must agree with global attribute <CODE>TIME_STEP</CODE>.
        <P>

        <DT> <CODE>VAR_UNITS <EM>(character(len&le;32)&nbsp;)</EM></CODE>
        <DD> Units specification for the indicated variable; should
        be MKS&nbsp;/&nbsp;UDUNITS compliant.
        <P>

        <DT> <CODE>VAR_DESC <EM>(character(len&le;80)&nbsp;)</EM></CODE>
        <DD> one-line text description of the variable.
        <P>

        <DT> <CODE>VAR_LEVELS <EM>(integer)</EM></CODE>
        <DD> Number of layers for the variable (either 1 or else matches
             <CODE>DOMAIN_LEVELS</CODE>.
        <P>

        <DT> <CODE>VAR_TYPE <EM>(integer)</EM></CODE>
        <DD> Data type the variable (<CODE>INTEGER, LOGICAL, REAL,
             REAL8</CODE>).
        <P>

        <DT> <CODE>VAR_STAGGER <EM> (character(len&le;32)&nbsp;) </EM> </CODE>
        <DD> NEW:  Stagger specification for the indicated variable;
        should be one of the following:  &quot;&quot;, &quot;X&quot;,
        &quot;Y&quot;, &quot;Z&quot;, &quot;XY&quot;, &quot;XZ&quot;,
        &quot;YZ&quot;, &quot;XYZ&quot;. Case is not significant.
        <P>
    </DL>
    </BLOCKQUOTE>

    <A HREF="#contents"><STRONG>Back to <EM>Contents</EM></STRONG></A>
    <P>

<HR> <!----------------------------------------------------------------->
<H2>
    <A NAME="addl">Additional Requirements for the WRF I/O&nbsp;API</A>
</H2>

    <BLOCKQUOTE>
    <EM>I'm not sure of the meaning of <CODE>WARNING</CODE> and
    <CODE>FATAL</CODE> in the error-value parameters in the list below;
    that issue should be re-visited.  Moreover, from what I can infer
    from <CODE>WRFV1/external/IOAPI</CODE> , the current list of
    status codes is altogether too closely tied to the current netCDF
    implementation of WRFIO.</EM>
    <P>

    <DL>
        <DT> <EM><STRONG>NOTE</STRONG></EM>
        <DD>  <EM>The WRF documentation to which I have access
              describes WRF date&amp;time representation variously as
              <CODE>character(len=19)</CODE>, &quot;accurate to exact
              milliseconds,&quot; and &quot;as exemplified by the
              format <CODE>0000-01-00:00:00.0000</CODE>&quot;. These
              are mutually inconsistent, and this inconsistency needs
              to be resolved.  Moreover, the code and documentation do
              not consistently specify the field-delimiters; I've coded
              my wrappers to look for any non-digits.</EM>
              <P>

        <DT>  <STRONG><A NAME="dt">Standard representation for 
              time-deltas</A> </STRONG>
        <DD>  (This may be already present, but I can't find it).  What
              I would suggest is that time deltas use a format adapted
              from the date&time representation: something like either
              <CODE>&lt;sign&gt;[[H*:]MM:]SS.SSS</CODE>
              or <CODE>&lt;sign&gt;H*:MM:SS.SSS</CODE> where the sign,
              hours, and minutes fields are optional.Note that since
              &quot;month&quot; and &quot;year&quot; do not have
              invariant meanings, there should not be month-fields and
              year-fields in a time step representation.
              <P>
              <EM><STRONG>NOTE</STRONG> In <CODE>module_date_time</CODE>, 
              the routines <CODE>geth_idts</CODE> and
              <CODE>geth_newdate</CODE> seem to imply that time-deltas
              should be integers.  This is an error if, as the comments
              in that very code indicate, date and time representation
              is <CODE>&quot;YYYY-MM-DD HH:MM:SS.ffff&quot;</CODE>.
              </EM>
              <P>

        <DT>  <STRONG>Specification of the <A NAME="vert">vertical</A>
              coordinate type(s)</STRONG>
        <DD>  There is a list of current candidates.  I need to know how
              many items there are in this list, and what the names of
              them are.  There also need to be standard
              <CODE>parameter</CODE> tokens for the corresponding WRF 
              vertical coordinate type IDs...which should go in one of
              the WRF &quot;constants&quot; modules--which one?
              <P>

        <DT><STRONG>Provision for Time Independent Variables</STRONG>
        <DD>  I do not see provision in the documentation nor what I
              interpret of the <CODE>Registry</CODE> for stating that
              a variable (such as terrain height, map scale factors,
              map rotation angles, and reference atmosphere).
              There need to be two extensions to the WRF to support this:
              augmentation of the <CODE>Registry</CODE> so that it
              allows the designation of a variable as time independent
              or time stepped, and a means within the WRF&nbsp;API to
              communicate this fact to WRFIO.  For this latter, the
              standard could be that a dry-run call to 
              <CODE>ext_<VAR>pkg</VAR>_write_field()</CODE> for which
              the <CODE>DateStr</CODE> argument is identically zero
              (i.e., <CODE>00:00:00.0000</CODE>) designates the
              corresponding variable as time independent.
              <P>

        <DT>  <STRONG>Grid and Map Projection characterization</STRONG>
        <DD>  Mathematically, the notion of a <VAR>grid</VAR> is
              subordinate to that of a  <VAR>map projection</VAR>:
              <BLOCKQUOTE>
              A <STRONG>map projection</STRONG> is a mapping from a domain on
              the surface of the Earth into a rectangle in a
              two-dimensional Cartesian space
              <STRONG>R<SUP>2</SUP></STRONG>.  The common mesoscale
              examples&nbsp;-- Lambert conformal conic, polar secant
              sterographic, equatorial Mercator&nbsp;-- require not
              only a set of (typically 3) defining angles, but also a
              Cartesian origin for their specification.  It is not
              necessarily the case that the Cartesian origin falls at
              an origin &quot;central lat-lon&quot; coincident with the
              defining angles of the projection.  This would seem to be
              an unwarranted assumption.  Moreover, at the <VAR>Meso-Gamma</VAR>
              and finer scales targeted by the WRF, there will be a
              desire (at least for air quality applications) to 
              support for the so-called <VAR>Universal Transverse
              Mercator (UTM)</VAR> map projections, by the way.
              <P>
              A <STRONG>grid</STRONG> has a map projection and a &quot;lattice
              structure&quot; defined in terms of that grid -- typically
              needing the following, of which I can find only the last
              two in the <VAR>Registry</VAR>.  One can not assume that
              the grid must be centered relative to the Cartesian origin
              of the map projection, especially as one goes to smaller
              scales (and there can be particular modeling advantages to
              having the grid off-center, if by so doing one can line up
              a coordinate axis with the prevailing winds of the domain
              modeled).
              <UL>
                  <LI>  starting corner <CODE>X1</CODE>, <CODE>Y1</CODE>
                        (e.g., the SW corner of the
                        <CODE>(1,1)</CODE>-cell)
                  <LI>  cell-size <CODE>DX</CODE>, <CODE>DY</CODE>
                  <LI>  dimensions <CODE>NX</CODE>, <CODE>NY</CODE>
              </UL><P>
              As far as I can tell, the WRF does not have any proper
              characterization of grids relative to the map projections
              within which they &quot;live&quot;.
              </BLOCKQUOTE>
              <P>

        <DT>  Routines for the <STRONG>definition of time-dependent
              metadata</STRONG>
        <DD>  <UL>
                  <LI> <CODE>ext_<VAR>pkg</VAR>_def_glb_td_char(DataHandle,Length,Status)</CODE>
                  <LI> <CODE>ext_<VAR>pkg</VAR>_def_glb_td_<VAR>type</VAR>(DataHandle,Count,Status)</CODE>
                  <LI> <CODE>ext_<VAR>pkg</VAR>_def_var_td_char(DataHandle,Var,Length,Status)</CODE>
                  <LI> <CODE>ext_<VAR>pkg</VAR>_def_var_td_<VAR>type</VAR>(DataHandle,Var,Count,Status)</CODE>
              </UL><P>
              <CODE><BLOCKQUOTE>
              INTEGER, INTENT( IN )::  DataHandle, Length, Count<BR>
              CHARACTER(len=*), INTENT( IN )::  Var<BR>
              INTEGER, INTENT( OUT )::  Status<BR>
              </BLOCKQUOTE></CODE>
              <P>
              <EM><STRONG>Constraint 1:</STRONG>  These methods must
              be called while the data set is in its data definition
              phase, prior to the call to </EM><CODE>
              ext_<VAR>pkg</VAR>_open_for_write_commit()</CODE>
              <P>
              <EM><STRONG>Constraint 2:</STRONG>  These methods must
              be called  prior to any call to a time dependent metadata
              routine </EM><CODE> ext_<VAR>pkg</VAR>_put_td*()</CODE>
              <P>
              <EM><STRONG>NOTE:</STRONG>  the draft-document prototypes
              for routines</EM>
              <CODE>ext_<VAR>pkg</VAR>_get_glb_td_*()</CODE> and
              <CODE>ext_<VAR>pkg</VAR>_get_dom_td_*()</CODE>
              <EM>need</EM> <CODE>DateStr</CODE> <EM>as an additional
              argument.</EM>
              <P>

        <DT> <STRONG><CODE>Program termination</CODE></STRONG>
        <DD>  In order for WRFIO data sets to have correctly updated
              headers (or the equivalent), all program terminations
              must cause the call of <CODE>ext_<VAR>pkg</VAR>_exit()</CODE>.
              <CODE>STOP</CODE> and <CODE>CALL EXIT()</CODE> should be
              forbidden.
              <P>

        <DT> <STRONG><CODE>WRF_ERR_INCOMPLETE_SD_DEF</CODE>
              parameter</STRONG>
        <DD>  It is a fatal error for data set creation to attempt to do
              a &quot;commit&quot; operation with a data set definition
              that is yet incomplete.
              <P>

        <DT> <STRONG><CODE>WRF_ERR_DEFN_CONSTRAINT </CODE>
              parameter</STRONG>
        <DD>  Constraint violation (e.g., setting a per-variable
              metadatum prior to establishment of the variable via
              dry-run <CODE>ext_<VAR>pkg</VAR>_write_field()</CODE> call.)
              <P>

        <DT><STRONG><CODE>WRF_ERR_FATAL_ </CODE> </STRONG> parameters
             for the following failures:
        <DD> Possibly one additional error-code <CODE>WRF_ERR_FUBAR</CODE>,
             or else specific error codes for the following:
             <UL>
                   <LI>  <CODE>ext_m3io_init()</CODE> failed
                   <LI>  <CODE>ext_m3io_init()</CODE> not yet called
                   <LI>  <CODE>ext_m3io_exit()</CODE> failed
                   <LI>  <CODE>ext_m3io_open_dataset_for_read()</CODE>
                   failed
                   <LI>  <CODE>ext_m3io_open_dataset_for_write_commit()</CODE>
                         when the supplied data set definition is not
                         complete: <CODE>WRF_ERR_INCOMPLETE_DS_DEF</CODE>
                   <LI>  <CODE>ext_m3io_inquire_opened()</CODE> when the
                         datahandle is incorrect for the specified file
                         name.
                   <LI>  <CODE>ext_m3io_close()</CODE> failed, when the
                         indicated file exists but the close operation
                         failed.
                   <LI>  <CODE>ext_m3io_*_md*()</CODE>:  metadata
                         <CODE>Element</CODE> not in data set.
                   <LI>  <CODE></CODE>
              </UL>
              <P>

    </DL>
    </BLOCKQUOTE>

    <P>
    <A HREF="#contents"><STRONG>Back to <EM>Contents</EM></STRONG></A>
    <P>

<HR> <!----------------------------------------------------------------->
<H2>
    <A NAME="sugn">Suggestions for Enhancing the WRF I/O&nbsp;API</A>
</H2>

    <BLOCKQUOTE>
    <DL>
        <DT> <STRONG>Time-interpolation</STRONG> method
              <CODE>
              ext_<VAR>pkg</VAR>_interp_field( <VAR>&lt;args&gt;</VAR>)
              </CODE>
        <DD>  where the argument list <CODE><VAR>&lt;args&gt;</VAR></CODE>
              is the same as that for
              <CODE>ext_<VAR>pkg</VAR>_read_field()</CODE>
              <BR>
              <EM><STRONG>Constraint:</STRONG>  The indicated variable
              must be of type <CODE>real</CODE> or <CODE>real8</CODE>.</EM>
              <P>
              The corresponding M3IO routine, 
              <CODE>INTERP3(FNAME,VNAME,&lt;date&amp;time&gt;,...)</CODE>,
              has proven quite valuable.  It interpolates variable
              <CODE>VNAME</CODE> from file <CODE>FNAME</CODE> to the
              specified date and time (or returns a failure-status if
              this is not possible).  The routine handles I/O
              optimization for the caller (i.e., maintains double
              buffering) behind the scenes.
              <P>

        <DT><STRONG>Time-Derivative</STRONG> method
              <CODE>
              ext_<VAR>pkg</VAR>_ddt_field( <VAR>&lt;args&gt;</VAR>)
              </CODE>
        <DD>  <EM><STRONG>Constraint:</STRONG>  The indicated variable
              must be of type <CODE>real</CODE> or <CODE>real8</CODE>.</EM>
              <P>
              Given the double-buffering of a time-interpolation routine,
              it is easy to construct a <EM>time-derivative</EM>
              routine using  the same buffer system.  Such a routine is
              occasionaly useful, e.g., for getting a rainfall rate
              from the prognostic cumulative rainfall variable.
              <P>

        <DT><STRONG>Windowed Output</STRONG>
        <DD>  For research and diagnostic purposes it may be worthwhile
              to make special provisions for the capability to output
              selected variables at high temporal frequency (e.g., the
              model time step), but only for a specified window into the
              model domain (resource requirements may make full-domain
              model time step output impractical).
              <P>

        <DT><STRONG>Layer-Selective input</STRONG> method
              <CODE>
              ext_<VAR>pkg</VAR>_read_field_level( <VAR>&lt;args&gt;</VAR>)
              </CODE>
        <DD>  where the argument list <CODE><VAR>&lt;args&gt;</VAR></CODE>
              augments that for
              <CODE>ext_<VAR>pkg</VAR>_read_field()</CODE>
              by adding an additional selector for model level.
              <P>
              Air quality modeling experience shows that there is
              relatively frequent use of the selective-read operations
              that pick out just one level (especially the model-bottom
              level) from a 3-D field.  Given a selective direct-access
              lower API-layer such as netCDF, this is quite easy to
              implement.
              <P>

        <DT><STRONG>Metadata-name-inquiry functions</STRONG>
        <DD>  Presently, only if the modeler <EM>already knows
              beforehand</EM> that a variable named <VAR>foo</VAR> has
              an attribute named <VAR>bar</VAR> and that the attribute
              has type <VAR>qux</VAR>, can the modeler inquire for the
              value of the attribute (and similarly for &quot;domain&quot;
              and &quot;global&quot; attributes).
              <P>
              Full functionality requires a complete set of inquiry
              functions that retrieve the names and types of all the
              per-variable, domain, and global metadata.  The end result
              would be a fully reflective metadata interface for WRFIO
              data sets.
              <P>

        <DT><STRONG>UNITS</STRONG>
        <DD>  I would like to suggest that units given for variables
              in the <CODE>Registry</CODE> should be compatible to
              the extent possible with the MKS UCAR <VAR>UDUNITS</VAR>
              package.  This reflects upon capitalization issues, so
              that one has, e.g., <CODE>M</CODE> instead of 
              <CODE>m</CODE> for &quot;meters&quot;.  (This is an
              operational requirement, rather than a software-system
              requirement...)
              <P>

        <DT>  <STRONG>Data set opening modes &quot;unknown&quot; and
              possibly &quot;create&quot; </STRONG>
        <DD>  One of the most useful M3IO file-open modes is
              <CODE>UNKNOWN</CODE>, which behaves as follows:
              <OL>
                  <LI>  The caller must supply a data set definition.
                  <LI>  If the file does not exist, create it according
                        to the caller-supplied definition.
                  <LI>  If the file exists, check that its definition
                        is consistent with the caller-supplied
                        definition.
                  <LI>  In particular, if the caller-supplied starting
                        date&amp;time is later than the file's starting
                        date&amp;time, the former must be a valid time
                        step for the latter.
              </OL>
              One of the <EM>least</EM> useful M3IO file-open modes is
              &quot;create&quot; mode:  if the file exists, delete it
              and create a new file according to the caller-supplied
              definition.  (This one was added at the insistence of the
              visualization people, who wanted it for scratch files, and
              who alone are allowed to use it: By agreement between the
              heads of EPA ORD and MCNC Environmental Modeling Center,
              modelers are forbidden to use this mode, on pain of being
              sentenced to not less than three years nor more than
              five years, on a 386/25 running Windows 3.0 and Microsoft
              Fortran 1.0. :-)  If the visualization people get wind of 
              this mode, they may insist upon it too...
              <P>

<!---
        <DT><STRONG>foo</STRONG>
        <DD>  bar
              <P>
--->
    </DL>
    </BLOCKQUOTE>


    <P>
    <A HREF="#contents"><STRONG>Back to <EM>Contents</EM></STRONG></A>
    <P>

<HR> <!----------------------------------------------------------------->
<H2>
    <A NAME="m4io">
    M4IO:  Enhancements to the Models-3 I/O&nbsp;API</A>
</H2>

    <BLOCKQUOTE>
    There are a number of potential modifications to the Models-3
    I/O&nbsp;API that would ameliorate incompatibilities between it and
    the WRF I/O&nbsp;API.  Some of these would cause source-code, link,
    or data incompatibilities with the existing M3IO (which has been
    carefully-maintained to preserve backward compatibility), and would
    at the very least lead to a
    <A HREF="http://www.tuxedo.org/~esr/jargon/html/entry/flag-day.html">
    &quot;flag day&quot;.</A>  For this reason, and because the
    WRF-Chem air quality model which (because of its planned use of
    SMOKE) is one of the  chief targets of this effort will in fact be
    a <EM>fourth generation</EM> air quality model (as the EPA's
    Models-3 is of the third generation), it is attractive to create a
    new library&nbsp;--&nbsp;<STRONG>M4IO</STRONG>&nbsp;--as a
    follow-on to M3IO.  At the same time (if for no other reason than
    SMOKE compatibility), it is desirable to make compatibility between
    M3IO and M4IO as great as possible.  It may be possible to make
    this almost entirely transparent by using Fortran-90 subroutine
    overloading for M4IO (although the Fortran-90 type system is not
    strong enough to do <EM>all</EM> that the API needs to do).
    <P>

    <EM><STRONG>NOTE: </STRONG>Given the time and level of effort
    required to implement all the M3IO enhancements given below, and
    the level of agreement with EPA needed for M4IO acceptance by them,
    we propose that for the initial WRFIO-to-M3IO implementation to be
    used for the Summer&nbsp;2002 air quality forecasting effort, we use the
    current version (Version&nbsp;2.1) of M3IO, and require the
    following constraints upon WRF configurations used with it:
    <UL>
        <LI>  Dates, times, and time steps are exactly representible in
              integer seconds (i.e., no fractional seconds).
        <LI>  Variable-names and units-designations have length at most
              16 characters.
        <LI>  No M3IO-nonstandard nor time dependent metadata will be
              stored.
        <LI>  WRFIO Data sets are represented as pairs of M3IO data
              sets, and have logical names built according to the
              formulas:
              <CODE>
        M3IONAME&nbsp;=&nbsp;TRIM(WRFIONAME);&nbsp;//&nbsp;_(2D|3D)
              </CODE>
              e.g., the WRF data set <CODE>HISTORY1</CODE> becomes the 
              pair of M3IO files <CODE>HISTORY1_2D</CODE> and
              <CODE>HISTORY1_3D</CODE>.
        <LI>  &quot;stagger&quot; implemented by padding on output, and
              pad-stripping on input, Z-stagger being implemented by 
              writing the surface level to the 2-D M3IO file and the
              elevated levels to the 3-D M3IO file.
    </UL>
    </EM><P>

    Potential changes/enhancements from M3IO that go into the new M4IO
    are the following:

    <DL>
        <DT>  <STRONG>Additional <CODE>LOGICAL</CODE> and
              <CODE>CHARACTER(LEN=&lt;n&gt;</CODE> field types</STRONG>
        <DD>  Currently, M3IO supports <CODE>READ3()</CODE> and 
              <CODE>WRITE3()</CODE> for fields only of types
              <CODE>INTEGER</CODE>, <CODE>REAL</CODE>, and
              <CODE>REAL8</CODE> (<CODE>INTERP3()</CODE> makes sense
              only for the last two of these).  It would be almost
              trivial to add support for <CODE>LOGICAL</CODE>; it has
              long been an EPA request to support fields of
              type <CODE>CHARACTER(LEN=&lt;n&gt;</CODE>, and we have
              recently worked out how to implement this cleanly,
              as well.<BR>
              <EM>
              Does not break backwards data, source, nor link
              compatibility.  <BR>
              NOTE:  netCDF does not support <CODE>LOGICAL</CODE>;
              do we handle this by overloading <CODE>INTEGER</CODE>?
              </EM>
              <P>

        <DT>  <STRONG>New &quot;extra-attribute&quot; M3IO
              routines</STRONG><BR>
        <DD>  <CODE>
              <A HREF="/products/ioapi/INQATT3.html">
              LOGICAL INQATT3</A>(FNAME,VNAME,NATTS,ANAMES,ATYPES,ASIZES)
              <BR>
              <BLOCKQUOTE>
        CHARACTER*(*)   FNAME             !  logical file name<BR>
        CHARACTER*(*)   VNAME             !  variable name, or &quot;ALL&quot;<BR>
        CHARACTER*(*)   ANAMES( MXATTS3 ) !  attribute names<BR>
        INTEGER         ATYPES( MXATTS3 ) !  " types (M3REAL,M3INT,M3DBLE)<BR>
        INTEGER         ASIZES( MXATTS3 ) !  " sizes/lengths<BR>
              </BLOCKQUOTE>
              <A HREF="/products/ioapi/RDATT3.html">
              LOGICAL RDATT3</A>(FNAME,VNAME,ANAME,ATYPE,AMAX,ASIZE,AVAL)<BR>
              <A HREF="/products/ioapi/RDATT3.html">
              LOGICAL RDATTC</A>(FNAME,VNAME,ANAME,CVAL )<BR>
              <A HREF="/products/ioapi/WRATT3.html">
              LOGICAL WRATT3</A>(FNAME,VNAME,ANAME,ATYPE,AMAX,AVAL)<BR>
              <A HREF="/products/ioapi/WRATT3.html">
              LOGICAL WRATTC</A>(FNAME,VNAME,ANAME,CVAL )<BR>
              <BLOCKQUOTE>
        CHARACTER*(*)   FNAME         !  logical file name<BR>
        CHARACTER*(*)   VNAME         !  variable name, or &quot;ALL&quot;<BR>
        CHARACTER*(*)   ANAME         !  attribute name<BR>
        INTEGER         ATYPE         !  attribute type (M3REAL,M3INT,M3DBLE)<BR>
        INTEGER         AMAX          !  attribute dimensionality<BR>
        INTEGER         ASIZE         !  attribute actual size<BR>
        REAL            AVAL( AMAX )  !  attribute value (numeric)<BR>
        CHARACTER*(*)   CVAL          !  attribute value (character-string)<BR>
              </BLOCKQUOTE>
              </CODE>
              <EM>
              Does not break backwards data, source, nor link
              compatibility.  <BR>
              Work currently underway (prototype version coded
              and in test at this time); should fit into Summer&nbsp;2002
              air quality prototype and be used for the initial
              implementation of <CODE>STAGGER</CODE>
              </EM>
              <P>

        <DT>  <STRONG>New &quot;disk-synchronization&quot; M3IO
              routine</STRONG><BR>
        <DD>  <CODE>
              <A HREF="/products/ioapi/SYNC3.html">
              LOGICAL SYNC3</A>(FNAME)
              <BR>
              <BLOCKQUOTE>
        CHARACTER*(*)   FNAME             !  logical file name<BR>
              </BLOCKQUOTE>
              </CODE>
              <EM>
              Does not break backwards data, source, nor link
              compatibility.  <BR>
              Work currently underway (prototype version coded
              and in test at this time); should fit into Summer&nbsp;2002
              air quality prototype and be used for the initial M3IO
              implementation.
              </EM>
              <P>



        <DT><STRONG>Higher-resolution date and time support</STRONG>
        <DD>  WRF uses millisecond resolution; is this the appropriate
              way to go?  There have been arguments in favor of three
              other approaches for date&time objects that are even
              stronger than millisecond temporal resolution (where
              below, <VAR>date</VAR> has a resolution of 1 day, and
              <VAR>time</VAR> has a resolution of 1 second):
              <VAR><UL>
                  <LI> &lt;date&amp;time&gt; = 
                       &lt;<CODE>INTEGER&nbsp;YYYYDDD</CODE> date &gt;
                       +&nbsp;&lt;<CODE>INTEGER&nbsp;HHMMSS</CODE> time&gt; 
                       +&nbsp;&lt;<CODE>REAL8&nbsp;0.SSS...</CODE> fractional
                       seconds&gt;
                  <LI> &lt;date&amp;time&gt; = 
                       &lt;<CODE>INTEGER YYYYDDD</CODE> date &gt;
                       +&nbsp;&lt;<CODE>REAL8&nbsp;HHMMSS.SS...</CODE>
                       time&gt; 
                  <LI> &lt;date&amp;time&gt; = 
                       &lt;<CODE>INTEGER YYYYDDD</CODE> date &gt;
                       +&nbsp;&lt;<CODE>INTEGER&nbsp;HHMMSS</CODE> time&gt; 
                       +&nbsp;&lt;<CODE>INTEGER&nbsp;FRAC(2)=(NUMERATOR,DENOMINATOR)</CODE>
                       rational-number fractional seconds&gt; 
              </UL></VAR>
              Note that for the first two of these, <CODE>REAL8</CODE>
              provides sufficient numerical precision to allow for the
              deterministic calculation of time step record numbers
              accurate to WRF's millisecond tolerances, even for very
              long time step sequences.  Multi-century runs would run
              into difficulty, however.  The rational-number approach
              has the virtue of exact arithmetic; however, it is much
              more complex both for us to implement and for the average
              modeler to use.  Currently, I (CJC) favor the first of
              these approaches, in terms of maximizing the combination
              of usability and precision.
              <BR><EM>Breaks backwards source and link compatibility.</EM>
              <P>

        <DT><STRONG>32-character variable names</STRONG>
        <DD>  M3IO currently supports 16-character variable names and
              units designations; WRF names are presently mandated to
              be at most 31-character.  (NOTE:  Length 32 bytes
              potentially gives alignment-improvements to the internal
              data structures used for implementation.)
              <BR><EM>Does not break backwards data nor source compatibility.
              Breaks backwards link compatibility.</EM><BR>
              <EM><STRONG>INTERIM STEP: </STRONG> modify M3IO internals
              so that it requires <U>trimmed</U> name lengths to be
              <U>at most</U> 16.<BR>
              <STRONG>Done, 1/20/2002</STRONG></EM>
              <P>

        <DT><STRONG>New vertical coordinate types for WRF</STRONG>
        <DD>  This one is trivial to add, without breaking backwards
              compatibility--it just adds new parameters in the
              <CODE>PARMS</CODE> include-file.
              <BR><EM>Does not break backwards data, source nor link
              compatibility</EM>
              <P>

        <DT><STRONG>Increased level-dimension support</STRONG>
        <DD>  Currently, M3IO stores a maximum of 101 full-level values
              in file headers and file-description data structures.
              This number could be increased as desired.<BR>
              <EM>What is an appropriate maximum for WRF? 256?
              512?</EM>
              <BR><EM>Does not break backwards data noir source
              compatibility; breaks link compatibility.</EM>
              <P>

        <DT><STRONG>Support for WRF &quot;stagger&quot;</STRONG>
        <DD>  There are two ways to accomplish this, as described above
              in the section <EM><A HREF="#defs"> Dataset Definition
              Issues</A></EM>:  to add a per-variable
              <CODE>STAGGER</CODE> attribute in M3IO data sets, and
              either (1)&nbsp;use it to adjust the actual dimensions
              for input and output, or (2)&nbsp;to pad pad all output
              variables out to the extent of those dimensions (and
              subset on input), on the basis of <CODE>STAGGER</CODE>.
              The former alternative gives smaller data set sizes and
              more efficient I/O, but at substantially greater code
              complexity and with the probability of hard-to-diagnose
              program crashes if old-M3IO programs are fed new-M3IO data
              sets.
              <P>
              <EM>The consequence is that different variables within a
              M3IO data set would have different dimensionality,
              breaking forwards compatibility&nbsp;--&nbsp;old
              implenmentations would be unable to read new
              &quot;staggered&quot; variables without scrambling
              them, and might generate hard-to-diagnose program
              errors in the process.
              Does not break backwards data compatibility.  
              Breaks backwards source and link compatibility,
              potentially in ways that lead to hard-to-diagnose
              bugs.</EM>
              <P>

        <DT><STRONG>NAMELIST support for logical names</STRONG>
        <DD>  M3IO by default uses environment variables
              (initialized by script commands <CODE>
              &quot;setenv&nbsp;foo&nbsp;/bar/qux/dingbats.dat&quot;)
              </CODE> to bind data set logical names (as used by
              model code) to physical path names (as used by system
              calls), whereas WRFIO has traditionally used
              <CODE>NAMELIST</CODE>s.  If possible, the relevant
              M3IO utility routines will be modified to use either
              environment variables, or an <CODE>M3IO_NAMELIST</CODE>,
              ideally in that priority order, to evaluate the bindings
              of logical names.  <CODE>M3IO_NAMELIST</CODE> will itself
              be either the logical name for the namelist-file, or
              else will be the physical path-name for a file to be 
              found in the current working directory.
              <P>
              <EM>NOTE:  Since the M3IO environment-variable utilities
              are themselves C called from the Fortran, it remains to
              be seen whether one can make this C code actually
              interpret the <CODE>NAMELIST</CODE>s.  Perhaps the way to
              do this is to make the initialization routine do a
              <CODE>putenv()</CODE>?</EM>
              <P>
              <EM>Does not break backwards data, source nor link
              compatibility</EM>
              <P>

        <DT><STRONG>Geodetic-Spheroid metadata</STRONG>
        <DD>  Presently, the knowledge of what spheroid is used for the
              map projection (and therefore for the geo-referencing of
              the data) is implicit, maintained in the head of the
              modeler.  Especially for coupled environmental modeling
              systems, this is less than satisfactory; the data sets
              should contain a complete and accurate characterization
              of their georegistration.
              <BR><EM>Does not break backwards data compatibility.
              Breaks backwards source and link compatibility,
              potentially in ways that lead to hard-to-diagnose
              bugs.</EM>
              <P>

        <DT><STRONG>User-Defined metadata</STRONG>
        <DD>  The present M3IO maintains a fixed set of global and
              per-variable metadata, with additional metadata stored
              as user-defined text in the (4800-character) file
              description and run/update description fields.  The goal
              would be to provide additional interface-methods that
              yield a reflective interface to this user-defined
              metadata.  We do <EM>not</EM> propose to relax the
              standards for mandatory metadata.
              <BR><EM>Does not break backwards data, source nor link
              compatibility.</EM>
              <P>

        <DT><STRONG>Fortran-90 overloaded-interface implementation</STRONG>
        <DD>  Careful implementatoin of this would allow a
              backwards-compatible implementation that uses Fortran-90
              polymorphism to handle the different kinds of time steps
              that may occur.  Michael Metcalf's <VAR>convert</VAR>
              program can be of some help here, although we have seen
              that it does not deal with <CODE>INCLUDE</CODE>-files
              correctly, distorts the layout of comments and code,
              and requires some manual fixup and checking.
              <BR><EM>Does not break backwards data compatibility.
              Minimizes effects upon source compatibility.  Breaks link
              compatibility.  Causes portability difficulties due to
              the variety of different ways vendors implement modules.</EM>
              <P>

        <DT><STRONG>New <VAR>Geospatial-Element Cell Complex</VAR>
              data type</STRONG>
        <DD>  This one isn't necessary for WRF (as it is presently
              conceived), nor for existing applications (although
              it would be useful for adding additional capabilities
              to SMOKE).  However, it does fulfill a request  from
              EPA for means to handle time-stepped/time-independent 
              geospatial-coverage and finite element data in an
              efficient and powerful manner. It currently exists
              in prototype form (not included in the standard M3IO
              release); the EPA proposal describing its original
              conception can be found <EM><A HREF="gefile.html">
              here</A></EM>
              <BR><EM>Does not break backwards data, source nor link
              compatibility.</EM>
              <P>

        <DT><STRONG>Additional software-implementation layers</STRONG>
        <DD>  Currently, the M3IO is layered on top of two software
              libraries used for physical data storage/communication: 
              netCDF (using files, and the netCDF2 Fortran interface),
              and PVM3, using the mailbox interface.  It is perhaps
              desirable to extend or modify this in a number of ways:
              <UL>
                  <LI>  Add additional lower software-layers --
                        particularly MPI2
                  <LI>  Update the netCDF interface to use netCDF3
                  <LI>  Revise the name-binding mechanism for greater
                        regularity in syntax (e.g., 
                        <CODE>setenv&nbsp;foo&nbsp;MPI:/bar/stuff</CODE>)
              </UL>
              <BR><EM>Does not break backwards data, source nor link
              compatibility.</EM>
              <P>

    </DL>

    </BLOCKQUOTE>
    <A HREF="#contents"><STRONG>Back to <EM>Contents</EM></STRONG></A>
    <P>

<HR> <!----------------------------------------------------------------->
<H2>
    <A NAME="wish">WRF Implementation Wishlist</A>
</H2>

    <BLOCKQUOTE>
    <DL>
        <DT>  <STRONG><CODE>wrf_io_flags.h,
              wrf_status_codes.h</CODE></STRONG> location
        <DD>  These are of <EM>general</EM> use for all external I/O
              packages and should not be squirreled away under the
              <CODE>io_netcdf</CODE> leaf subdirectory.
              <P>

        <DT><STRONG>UTM map projection support</STRONG>
        <DD>  These are a <I>de facto</I> standard for urban-scale
              air quality applications, and will be useful to support
              the urban-scale air quality modeling community (which
              already has its emissions databases configured in terms
              of UTM; note that emissions database development is one
              of the most resource-intensive activities in such air
              quality applications.  Satisfying this request would
              largely be a matter of getting the correct preprocessor
              support; moreover, since almost all the original terrain
              and land cover databases are defined with respect to UTM,
              this should not be difficult (and would potentially avoid
              the loss of resolution that currently occurs when such
              data is re-mapped to another map projection.
              <P>

        <DT><STRONG>Names and Keywords</STRONG>
        <DD>  Don't use variable names that happen to be the same as
              Fortran keywords, e..g, <CODE>DATA</CODE> in the argument
              list or implementation of
              <CODE>ext_<VAR>pkg</VAR>get_glb_md_<VAR>type</VAR>()</CODE>.
              <P>

        <DT><STRONG>foo</STRONG>
        <DD>  bar
              <P>
    </DL>
    <P>

    <P>

    </BLOCKQUOTE>
    <A HREF="#contents"><STRONG>Back to <EM>Contents</EM></STRONG></A>
    <P>

<HR> <!----------------------------------------------------------------->
<H2>
    <A NAME="impl">Layered WRFIO/M3IO Implementation Strategy</A>
</H2>

    <H3>
    Date&amp;Time Routines
    </H3>

    <BLOCKQUOTE>

        The first requisite for layering WRFIO on top of an external
        M3IO package is to implement the simpler related objects and
        methods--such as date&amp;time conversion routines--on top of
        which the API is built.
        <P>
        <DL>
            <DT> <EM><STRONG>QUESTION&nbsp;1: </STRONG>
            <DD>  Can we nail down that the WRF time-delta represention
                  <A HREF="#dt">is as suggested above</A>:  similar to
                  the  WRF date&amp;time representation,except that
                  it may have a leading minus sign, 
                  it has hour, minute, and seconds fields, and that the
                  leading fields may be missing? e.g.,</EM>
                  <BLOCKQUOTE>
                  <CODE>12.375</CODE> <EM>twelve-and-three-eighths
                  seconds</EM><BR>
                  <CODE>08-00-00.000</CODE> <EM>eight hours</EM><BR>
                  <CODE>-08-00-00.000</CODE> <EM>negative eight
                  hours</EM><BR>
                  <CODE>168-00-00.000</CODE> <EM>one hundred sixty-eight
                  hours (one week)</EM>
                  </BLOCKQUOTE>
                  <EM>Note that the use of a hyphen as the delimiter
                  in WRF date&amp;time representation makes the
                  construction and interpretation of negative
                  time-differences rather trickier!</EM>
            <P>
            <DT> <EM><STRONG>QUESTION&nbsp;2: </STRONG>
            <DD>  Can we assume that the
                  separator in the date&amp;time character
                  strings is always a hyphen? (i.e., so that
                  date-strings look like </EM>
                  <CODE>&quot;YYYY-MM-DD-HH-MM-SS.SSS&quot;</CODE>
            <P>
            <DT> <EM><STRONG>QUESTION&nbsp;3: </STRONG>
            <DD>  Are WRF date&amp;time objects always normalized?
                  Or can things like
                  </EM> <CODE>2001-12-32-01-00-00.000</CODE>
                  <EM> (that &quot;ought to be&quot; 1&nbsp;A.M. on
                  Jan.&nbsp;1, 2002) happen?</EM>
            <P>
            <DT> <CODE><STRONG>SUBROUTINE 
                 wrftime2m3io(DateStr,JDate,JTime[,&nbsp;Frac])</STRONG></CODE>
            <DD> <CODE>character(len=*), intent(in):: DateStr<BR>
                 integer, intent(out):: JDate, JTime<BR>
                 REAL8, intent(out)::   Frac</CODE>
                 <P>
                 Overloaded module routine that converts from WRF 
                 <CODE>&quot;YY-MM-DD-HH-MM-SS.SSS&quot;</CODE>
                 character string time representation
                 to (extended) M3IO 
                 <CODE>integer YYYYDDD:HHMMSS[:0.xxxxD0]</CODE>
                 time representation
            <P>
            <DT> <CODE><STRONG>SUBROUTINE
                 m3iotime2wrf(JDate,JTime[,&nbsp;Frac],DateStr)</STRONG></CODE>
            <DD> <CODE>integer, intent(in):: JDate, JTime<BR>
                 REAL8, intent(in)::   Frac<BR>
                 character(len=19), intent(out):: DateStr</CODE>
                 <P>
                 Overloaded module routine that converts from M3IO 
                 <CODE>integer YYYYDDD:HHMMSS[:0.xxxxD0]</CODE>
                 time representation to WRF character string
                 time representation
                 <P>
            <DT> <CODE><STRONG>WRFDT2M3IO( DTStr, Tstep[, Tfrac] )</STRONG></CODE>
            <DD> <CODE>character(len=*), intent(in):: DTStr<BR>
                 integer, intent(out):: TStep<BR>
                 REAL8, intent(out)::   TFrac</CODE>
                 <P>
                 Overloaded module routine that converts a standard WRF
                 time-delta (once that is defined) into M3IO time-delta
                 representation.<BR> <EM>Note that M3IO already has
                 functions that convert back and forth between seconds
                 abd M3IO time-delta representation</EM>.
                 <P>
            <DT> <CODE><STRONG>M3IODT2WRF( Tstep[, Tfrac], DTStr )</STRONG></CODE>
            <DD> <CODE>
                 integer, intent(out):: TStep<BR>
                 REAL8, intent(out)::   TFrac<BR>
                 character(len=*), intent(out):: DTStr</CODE>
                 <P>
                 Overloaded module routine that converts a standard WRF
                 time-delta (once that is defined) into M3IO time-delta
                 representation.<BR> <EM>Note that M3IO already has
                 functions that convert back and forth between seconds
                 abd M3IO time-delta representation</EM>.
                 <P>

       </DL>
       <P>
    </BLOCKQUOTE>

    <H3>
    Mapping WRFIO Data Sets to M3IO Data Sets
    </H3>

    <BLOCKQUOTE>

        Each WRF data set will be implemented as a <STRONG>set of
        M3IO data sets</STRONG>, as necessitated by the fact  that
        individual M3IO data sets have homogeneous time step, layer, 
        and horizontal grid structures.  The decision of just how
        &quot;stagger&quot; is implemented will determine just how
        many M3IO data sets there will be for each WRF data set.
        <P>

        Another issue that comes up in this regard is the issue of
        <STRONG>name bindings</STRONG>:  both the WRFIO and the M3IO
        systems achieve directory independence by mapping <VAR>logical
        names</VAR> for data sets into <VAR>physical (path) names for
        files</VAR>.  Logical names are program-properties but do not
        imply actual file-system location or implementation by other 
        means.  This independence allows M3IO transparently to support
        both persistent file-based data sets and PVM-mailbox based
        communications channels for coupling a set of cooperating
        processes (as will be used initially to couple SMOKE with WRF.
        M3IO uses environment variables (e.g., set using the
        <VAR>csh</VAR> <CODE>setenv</CODE> command) to bind logical
        names to physical names; WRF traditionally uses
        <CODE>NAMELIST</CODE>s.  It may be possible to enhance the
        underlying M3IO environment variable routines so that they
        support both means of name binding.  If so, this allows us
        to perform a transparent &quot;behind the scenes &quot;
        upgrade that supports both means of name bindings when the
        enhanced routines become available.
        <P>
        
        <EM>For the initial implementation to be used for the
        Summer&nbsp;2002 air quality forecast effort, we propose
        that the <CODE>ext_m3io_ </CODE> package behave as follows:
        <UL>
             <LI>  Each WRFIO data set is implemented as a pair of
                   M3IO data sets:  the 2-D data set and the 3-D data
                   set.
             <LI>  Initially, &quot;stagger&quot; will be implemented 
                   by padding,
             <LI>  Environment variable name binding will be employed.
        </UL></EM>

     </BLOCKQUOTE>

    <H3>
    Design/Implementation Structure:  <CODE>module_m3io.F90</CODE> and 
    wrappers-file <CODE>ext_m3io.F90</CODE>
    </H3>

    <BLOCKQUOTE>

        This module encapsulates the state necessary to maintain the
        WRF datasets, as well as the input and output frames for each
        of them.  It is <CODE>USE</CODE>d by the subroutines in
        <CODE>ext_m3io.F90</CODE>, which implements all of the
        <CODE>ext_m3io_*()</CODE> wrapper calls that give the WRFIO
        external-package API interface.  The  <CODE>ext_m3io_*()</CODE>
        routines provide Fortran-77 style (in practice, this means
        call-by-reference) implicit calling interfaces rather than
        explicit interfaces; this is necessitated by the fact that
        the subroutines (such as <CODE>ext_m3io_write_field()</CODE>
        which writes both 2D and 3D fields of types <CODE>INTEGER</CODE>,
        <CODE>LOGICAL</CODE>, <CODE>REAL</CODE>, and <CODE>REAL8</CODE>)
        are overloaded to act upon what an explicit Fortran-90
        interface would see as incompatible argument lists.  (IMNHO, 
        the lack of a &quot;void pointer&quot; type is a serious defect
        in the Fortran-9x standards, but we can't really do anything
        about it.)
        <P>

        <DL>
            <DT><STRONG>Wrapper-routines in <CODE>ext_m3io.F90</CODE></STRONG>
            <DD>  Each of the routines in the <CODE>ext_m3io_*()</CODE>
                  API has an implementation that wraps M3IO calls for
                  WRF, and maintains the state tables in
                  <CODE>module_m3io</CODE> accordingly.
                  <P>

            <DT><STRONG><CODE>PARAMETER</CODE>s in <CODE>module_m3io</CODE></STRONG>
            <DD>  The M3IO parameters from <CODE>PARMS3.fh</CODE> are
                  <CODE>INCLUDE</CODE>d.  Additionally, there are
                  <UL>
                     <LI> <CODE>INTEGER, PARAMETER:: WRF_ERR_FUBAR</CODE>:
                          Otherwise-unclassified WRFIO-M3IO error.
                     <LI> <CODE>INTEGER, PARAMETER::  MXWRFIO</CODE>
                     <LI> <CODE>INTEGER, PARAMETER::  WRF_ERR_INCOMPLETE_DS_DEF </CODE>:
                     <LI> <CODE>INTEGER, PARAMETER::  FS_PENDING</CODE>
                          token to indicate a data set is currently in
                          the dry-run state.
                     <LI> tbd...<CODE></CODE>
                  </UL>
                  <P>

            <DT><STRONG>Data Structures in <CODE>module_m3io</CODE></STRONG>
            <DD>  tbd... 
                  <P>

            <DT><STRONG>State Variables in <CODE>module_m3io</CODE></STRONG>
            <DD>  tbd... We need to 
                  <UL>
                     <LI>  Current number <CODE>NWRFIO</CODE> of data sets
                     <LI>  List <CODE>FNAME</CODE> of current data set
                           names.
                     <LI>  Lists <CODE>FID2D</CODE> and <CODE>FID3D</CODE> of
                           <CODE>STATE3</CODE> ID's for the 2D and 3D
                           M3IO files mapped to the current data set.
                     <LI>  Lists of standard metadata values for data
                           sets currently in the dry-run state.
                     <LI>  tbd...<CODE></CODE>
                  </UL>
                  <P>

            <DT><STRONG>Internal Subroutines in
                <CODE>module_m3io</CODE></STRONG>
            <DD>
                <DL>
                   <DT><CODE>INTEGER m3io_get_att_&lt;type&gt;(FID,VID,ATTNAME,ATT)</CODE>
                   <DD><CODE>
                       INTEGER, intent(IN)::  FID     !  m3io file ID<BR>
                       INTEGER, intent(IN)::  VID     !  m3io vble ID, or 0 for global<BR>
                       CHARACTER(len=*), intent(IN):: ATTNAME     ! attribute-name<BR>
                       &lt;type&gt;, intent(IN):: ATT     !  attribute<BR>
                       </CODE>
                       There is one such function for each <CODE>type</CODE> in
                       <CODE>{character(len=*), integer, real, REAL8 }</CODE>
                       These functions are used to store only the non-M3IO variable or
                       data set attributes<BR>
                       <P>

                   <DT><CODE>INTEGER m3io_put att_&lt;type&gt;(FID,VID,ATTNAME,ATT)</CODE>
                   <DD><CODE>
                       INTEGER, intent(IN)::  FID     !  m3io file ID<BR>
                       INTEGER, intent(IN)::  VID     !  m3io vble ID, or 0 for global<BR>
                       CHARACTER(len=*), intent(IN):: ATTNAME     ! attribute-name<BR>
                        &lt;type&gt;, intent(OUT):: ATT     !  attribute<BR>
                       </CODE>
                       Retrieve the indicated per-variable attribute
                       for the indicated variable or the indicated global
                       dataset attribute from the ndicated M3IO file.<BR>
                       There is one such function for each <CODE>type</CODE> in
                       <CODE>{character(len=*), integer, real, REAL8
                       }</CODE>.
                       These functions are used to retrieve only the non-M3IO
                       variable or data set attributes.<BR>
                       <EM><STRONG>Constraint: </STRONG> Dataset must be in
                       define-mode, else the call is an error.</EM>
                       <P>

                   <DT><CODE>SUBROUTINE wrftime2m3io(WRFTIME,JDATE,JTIME[,SECFRAC])</CODE>
                   <DD><CODE>
                       CHARACTER(LEN=*), INTENT(  IN )::  WRFTIME<BR>
                       INTEGER         , INTENT( OUT )::  JDATE, JTIME<BR>
                       REAL8           , INTENT( OUT )::  SECFRAC<BR>
                       </CODE>
                       This polymorphic routine implements the
                       conversion from character string based WRF
                       date&amp;time representation to numeric M3IO or
                       extended M3IO date&amp;time representation.
                       <P>

                   <DT><CODE>SUBROUTINE m3iotime2wrf(JDATE,JTIME,[SECFRAC,]WRFTIME)</CODE>
                   <DD><CODE>
                       INTEGER          , INTENT(  IN ):: JDATE, JTIME<BR>
                       REAL8            , INTENT(  IN ):: SECFRAC<BR>
                       CHARACTER(LEN=*), INTENT( OUT ):: WRFTIME<BR>
                       </CODE>
                       This polymorphic routine implements the
                       conversion from the numeric M3IO or extended
                       M3IO date&amp;time representation to character
                       string based WRF date&amp;time representation
                       <P>

                   <DT><CODE></CODE>
                   <DD><CODE>
                       </CODE>
                       <P>

                   <DT><CODE></CODE>
                   <DD><CODE>
                       </CODE>
                       <P>

                   <DT><CODE></CODE>
                   <DD><CODE>
                       </CODE>
                       <P>

                   <DT><CODE></CODE>
                   <DD><CODE>
                       </CODE>
                       <P>

                   <DT><CODE></CODE>
                   <DD><CODE>
                       </CODE>
                       <P>

                   <DT><CODE></CODE>
                   <DD><CODE>
                       </CODE>
                       <P>

                </DL>
                <P>

            </DL>

    </BLOCKQUOTE>

    <A HREF="#contents"><STRONG>Back to <EM>Contents</EM></STRONG></A>
    <P>

<HR> <!----------------------------------------------------------------->
<H2>
    <A NAME="">dummy</A>
</H2>

    <BLOCKQUOTE>
    <P>

    </BLOCKQUOTE>
    <A HREF="#contents"><STRONG>Back to <EM>Contents</EM></STRONG></A>
    <P>

<HR> <!----------------------------------------------------------------->

<H2>
    <A NAME="refs">References</A>
</H2>


    <OL>
        <LI>  <A HREF= "index.html">Models-3/EDSS I/O API Homepage</A>
              <P>
        <LI>   <A HREF= "COUPLING.html">I/O&nbsp;API Coupling Mode
               page</A>
              <P>
        <LI>  <A HREF= "MCPL.html"> MCNC Environmental Modeling Center, The MM5 MCPL()
              Meteorology-Coupler I/O&nbsp;API Module.</A>
              <P>
        <LI>  Carlie J. Coats, Jr., MCNC Environmental Modeling Center,
              Coupling-Mode Extensions for the Models-3 I/O API,
              notes for a talk delivered at the EPA Workshop on the
              Multimedia Integrated Modeling System, Research Triangle
              Park, NC, August 15-17 2000.
              <EM><A HREF=
              "http://www.baronams.com:/projects/ppar/coupling_mode.html">
              /projects/ppar/coupling_mode.html
              </A></EM>
              <P>
        <LI>  MCNC Environmental Modeling Center,  Sparse Matrix Operator
              Kernel Emissions (SMOKE) Modeling System.
              <EM><A HREF=
              "http://www.baronams.com:/products/smoke/index.html">
              /products/smoke/index.html
              </A></EM>
              <P>
        <HR> <!--------------------------------------------------------->
        <LI>  OpenMP Home Page. <EM><A HREF="http://www.openmp.org/">
              http://www.openmp.org/
              </A></EM>
              <P>
        <LI>  PVM Home Page. <EM><A HREF="http://www.epm.ornl.gov:80/pvm/">
              http://www.epm.ornl.gov:80/pvm/</A></EM>
              <P>
        <LI>  NetCDF Home Page.  <EM><A HREF=
              "http://www.unidata.ucar.edu/packages/netcdf/index.html">
              http://www.unidata.ucar.edu/packages/netcdf/index.html</A></EM>
              <P>
        <LI>  Metcalf and Reid's convert.f90<EM><A HREF=
              "ftp://ftp.numerical.rl.ac.uk/pub/MandR/convert.f90">
              ftp://ftp.numerical.rl.ac.uk/pub/MandR/convert.f90</A></EM>
              <P>
        <LI>  <EM><A HREF="">
              </A></EM>
              <P>
    </OL>



    <P>
    <A HREF="#contents"><STRONG>Back to <EM>Contents</EM></STRONG></A>
    <P>

<HR> <!----------------------------------------------------------------->
Send comments to 
<A HREF = "mailto:cjcoats@email.unc.edu"> <ADDRESS> 
          Carlie J. Coats, Jr. <br> 
          cjcoats@email.unc.edu  </ADDRESS> </A><P> 

<!--#include virtual="/INCLUDES/footer.html" -->
</BODY>      <!--end body  -->
</HTML>      <!--end html  -->



<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- "$Id$" -->
<META NAME="MSSmartTagsPreventParsing" CONTENT="TRUE"> 
<TITLE> TUTORIAL:  Using the I/O API </TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF"
      TOPMARGIN="15" 
      MARGINHEIGHT="15" 
      LEFTMARGIN="15" 
      MARGINWIDTH="15">

<!--#include virtual="/INCLUDES/header.html" -->

<H1>    TUTORIAL:  Using the I/O API </H1>
        
        
<H2> Introduction </H2>

The Models-3/EDSS <STRONG> I/O API </STRONG> is intended to provide 
an easy-to-learn, easy-to-use interface to data files for the model 
and model-related-tool developer.  There are only a few topics you'll 
need to know about:
<UL>
    <LI> <A HREF = "#files"> 
         Files, Logical Names and Physical Names 
         </A>

    <LI> <A HREF = "#start"> 
         How to start up and shut down the I/O API 
         </A>

    <LI> <A HREF = "#open"> 
         How to open or create files 
         </A>

    <LI> <A HREF = "#read"> 
         How to read data from files 
         </A>

    <LI> <A HREF = "#write"> 
         How to write data to files 
         </A>

    <LI> <A HREF = "#buffered"> 
         How to use &quot;buffered virtual&quot; files </A> for 
         intermodule data exchange
    
    <LI> <A HREF = "#descriptions"> 
         What are the file descriptions and types of data supported 
         </A>
    
    <LI> <A HREF = "#conventions"> 
         How to manipulate dates and times, and other conventions
         </A>
</UL>

The I/O API is a selective and direct-access interface to the data:  
you tell the system what variables and dates and times you're talking 
about and it figures all the stuff about record numbers, etc., for 
itself.  Also, you don't have to read the data in consecutive order, 
or to write it in order, either -- you just ask for what you want, and 
the I/O API finds it for you (although there are moderate performance
penalties for writing data out-of-order).  The files are self-describing 
files -- that is, the file headers have all the dimensioning and descriptive 
information needed about the data in them.  
<P> 

There are versions of the I/O API callable from both 
<A HREF = "FORTRAN.html"> Fortran </A> and from 
<A HREF = "C.html"> C </A>.  This document describes the Fortran 
interface; the <A HREF = "C.html"> C interface </A> is very 
similar.  The major difference between the two are that Fortran LOGICAL 
functions returning .TRUE. or .FALSE. correspond to C functions returning 
1 or 0, Fortran <CODE>&quot;.EXT&quot;</CODE> 
<A HREF = "INCLUDE.html"> include-files </A> correspond one-to-one to 
C <CODE>&quot;.h&quot;</CODE> include files, and the C calls 
look much like the Fortran calls, except that file descriptions are 
passed via pointers to data structures typedeffed in <VAR>fdesc3.h</VAR> 
instead of a <CODE>COMMON</CODE> found in <CODE>FDESC3.EXT</CODE>
<P>

There are <STRONG> 9 routines</STRONG> you'll need to know:
<A HREF = "#start"> <STRONG>INIT3()</STRONG> and <STRONG>SHUT3()</STRONG> </A> 
to start up and shut down 
the I/O API; 
<A HREF = "#open"> <STRONG>OPEN3()</STRONG> </A> to open files; 
<A HREF = "#desc"> <STRONG>DESC3()</STRONG> </A> to get file descriptions; 
<A HREF = "#read"> <STRONG>READ3()</STRONG>, <STRONG>INTERP3()</STRONG>, 
<STRONG>XTRACT3()</STRONG>, and <STRONG>DDTVAR3()</STRONG> </A>
to access data values; and <A HREF = "#write"> <STRONG>WRITE3()</STRONG> </A> 
to store data to files.  Additionally, <A HREF = "M3EXIT.html"> 
<STRONG>M3EXIT()</STRONG> </A> is a useful utility routine which works 
with the I/O API to generate exit (or error) messages to the 
<A HREF = "ENVIRONMENT.html"> program log</A>, 
call SHUT3(), and then terminate the program with a user-supplied
exit status (which should be 0 for success and nonzero for failure).
There are three <STRONG>INCLUDE</STRONG> files you'll have to worry about.
Each has extensive in-line documentation describing how it is used.  
<A HREF = "INCLUDE.html#parms"> <STRONG>PARMS3.EXT</STRONG> </A> 
contains the dimensioning parameters and the &quot;magic number&quot; 
parameters used to control the operation of various routines in the I/O API.  
<A HREF = "INCLUDE.html#fdesc"> <STRONG>FDESC3.EXT</STRONG> </A> has 
commons that hold file descriptions (more about that later); it needs 
<CODE>PARMS3.EXT</CODE> for its own dimensioning.  Finally, 
<A HREF = "INCLUDE.html#iodecl"> <STRONG>IODECL3.EXT</STRONG> </A> 
has declarations and usage comments for the various functions in the 
I/O API (it's really a short manual on the I/O API in its own right).

     <H2> <A NAME = "files"> 
     Files , Logical Names and Physical Names 
     </A> </H2>

The I/O API stores and retrieves data using 
<A HREF = "BUFFERED.html"> <STRONG>files</STRONG> and 
<STRONG>virtual files</STRONG> </A>, which have (optionally) multiple 
<A HREF = "DATATYPES.html#timestruct"> time steps </A> of multiple
<A HREF = "VBLE.html"> layers of multiple variables </A>.  Files are 
formatted internally so that they are machine and network-independent -- 
you can FTP them freely across a wide variety of machines, or read 
files NFS-mounted from other machines, as well.  (This behavior is 
unlike Fortran files, whose internal formats are vendor specific, so 
that the files don't FTP or NFS-mount very well).  Each file has an 
internal description, consisting of the 
<A HREF = "DATATYPES.html"> file type </A>, the 
<A HREF = "GRIDS.html"> grid and coodinate descriptions </A>, a set of 
descriptions for the file's set of <STRONG>variables</STRONG>, i.e., names, 
units specifications, and text descriptions.  Each variable a set of 
<STRONG>layers</STRONG> and a sequence of <STRONG>time steps</STRONG> 
(quite possibly only one layer for some kinds of data, if you want, or only 
one time step, for time-independent data).  In dealing with the files, 
we'll refer to files and variables by names, layers by number (from 1 
to the number of layers in the file), and dates and times according 
to conventions described later.  Rather than forcing the programmer 
and program-user to deal with hard-coded file names or hard-coded 
unit numbers, the I/O API introduces the concept of 
<A HREF = "LOGICALS.html"> <STRONG>logical file names</STRONG> </A>.  
As a modeler, you can define your own logical names as 
properties of a program (or even prompt the user for his own preferred
logical names at run time) and then at run-time connect up the 
logical names to any &quot;real&quot; file name you want to, using the 
UNIX <CODE>csh setenv </CODE> command.  Additionally, there are four
<A HREF = "ENVIRONMENT.html"> standard logical names</A>:
LOGFILE, SCENFILE, and EXECUTION_ID, which may be used for the 
program log file, scenario-description file, and execution identifier, 
and <A HREF = "GRIDDESC.html"> GRIDDESC </A>, for ASCII grid and 
coordinate system databases used by utility routine
<A HREF = "DSCGRID.html"> DSCGRID()</A>.
For programming purposes, the significant facts are that names should 
not contain blanks (except at the end: <CODE>&quot;foo  &quot;</CODE> is OK; 
<CODE>&quot;f  oo&quot;</CODE> is not), and are at most 16 characters long.  

When you run a program that uses the I/O API, you begin with a 
sequence of <CODE>setenv</CODE> commands that set the values for the 
program's logical names, much as you begin a (normal) Cray Fortran 
program with a sequence of <CODE>ASSIGN</CODE> commands for its files.  
For example, if &quot;<CODE>myprogram</CODE>&quot; has logical names 
&quot;<CODE>foo</CODE>&quot; and &quot;<CODE>bar</CODE>&quot; that I 
want to connect up to files &quot;<CODE>somedata.mymodel</CODE>&quot; 
and &quot;<CODE>otherdata.whatever</CODE>&quot; from directory 
&quot;<CODE>/tmp/mydir</CODE>&quot;, the script for the program would 
look something like:
<PRE>
    ...
    setenv foo          /tmp/mydir/somedata.mymodel
    setenv bar          /tmp/mydir/otherdata.whatever
    setenv qux          &quot;/tmp/mydir/volatilestuff.mymodel -v&quot;
    setenv LOGFILE      /tmp/mydir/mymodel.log
    setenv SCENFILE     /tmp/mydir/test17a.description
    setenv EXECUTION_ID TEST17A
    /user/mydir/myprogram
    ...
</PRE>
 
<A HREF="BUFFERED.html#vol">VOLATILE files</A>  are indicated by a 
trailing <CODE>&nbsp;-v</CODE> in the <VAR>setenv</VAR> command, as
above, in order to tell the I/O&nbsp;API to perform disk-synch
operations before every input and after every output operation on that
file.  Such files can be accessed by other programs while the
generating program is still running, and are readable even if it fails
to do a <A HREF="SHUT3.html">SHUT3()</A> or
<A HREF="M3EXIT.html">M3EXIT()</A> (or if it crashes unexpectedly). 
<P>

<A HREF="BUFFERED.html#buf">BUFFERED virtual files</A> can be used to
provide safe, structured exchange of data -- of &quot;gridded&quot;,
&quot;boundary&quot;, or &quot;custom&quot;  types only -- between
different modules in the same program.  If you  <CODE>setenv</CODE> 
the value of a logical name to the value  <CODE>BUFFERED</CODE>, as
given below:
<PRE>
    ...
    setenv qux BUFFERED
    ...
    /user/mydir/myprogram
    ...
</PRE>   
then the I/O API will establish in-memory buffers and time indexing 
for &quot;qux&quot; instead of creating a physical file on disk.  One module 
can then use <A HREF = "#write"> WRITE3() </A> (see below) to export data 
for sharing, which other modules would then use 
<A HREF = "#read"> READ3() or INTERP3() </A> to import.  Note 
that since these routines associate the data with its simulation 
date-and-time, the system will notice the error (and warn the user) 
if you attempt to get and use data before it has been produced.  
Note also that by changing the <VAR>setenv</VAR> in the script between 
&quot;BUFFERED&quot; and a physical file-name, you can change between 
efficient data sharing between modules and high-resolution 
instrumentation of the data being shared, without changing the 
underlying program at all.  
<P> 

<A HREF="BUFFERED.html#pvm">COUPLING-MODE virtual files</A> can be
used to provide PVM-based data exchange between cooperating programs
using exactly the unchanged I/O&API programming interface, with the
kind of name-based direct-access semantics that provides, with the
extra scheduling condition that requests for data that has not yet been
written put the requester to sleep until it becomes available (at which
time the requester is awaked and given the requested data).  The
decision of which files are disk-based and which are COUPLING-MODE
virtual files is also made by <VAR>setenv</VAR> commands at
program-launch, the value being of the form 
&quot;virtual&nbsp;&lt;communications-channel-name&gt;&quot;:
<PRE>
    ...
    setenv  zok  &quot;virtual CHEM_CONC_3D_G3&quot;
    /user/mydir/myprogram
    ...
</PRE>   
<P>

Except for INIT3(), all of the I/O API routines are LOGICAL functions 
returning TRUE for success and FALSE for failure.  
<P> 

There are a number of <A HREF = "INCLUDE.html#dims"> dimensioning </A> 
parameters and <A HREF = "INCLUDE.html#magic"> &quot;magic number&quot; </A>
token values for the I/O API.  Throughout the I/O API, names (logical file 
names, variable names, and units) are character strings with maximum 
length NAMLEN3 = 16; descriptions are either one or 
MXDESC3 = 60 lines of length at most MXDLIN3 = 80.  
The I/O API currently supports up to MXFILE3 = 50 open files, 
each with up to MXVARS3 = 120 variables.
<P> 


<H2> <A NAME = "descriptions"> 
     What Are the File Descriptions and Types of Data Supported 
     </A> </H2>

All files manipulated by the I/O API have multiple variables, each 
having possibly multiple layers.  Within a file, all the variables 
are data arrays have the same dimensions, number of layers and the 
same <A HREF = "DATATYPES.html#struct"> structure-type of data </A>, 
although possibly different <A HREF = "DATATYPES.html#basic"> basic types </A>
(e.g., gridded and boundary varaibles can't be mixed within the same file,
but real and integer variables can).  Each file has a 
<A HREF = "DATATYPES.html#timestruct"> time step structure </A> 
shared by all of its variables, as well.  
There are three kinds of time-step structure supported:
<UL>
    <LI>  <STRONG>Time-independent.</STRONG>  The file's time-step 
    attribute is set to zero.  
    Routines which deal with time-independent files ignore the date 
    and time arguments.

    <LI>  <STRONG>Time-stepped.</STRONG>  The file has a starting date, 
    a starting time,  and a positive time step.  Read and write requests 
    must be for  some positive integer multiple of the time step from 
    the starting  date and time, or they will fail.

    <LI>  <STRONG>Circular-buffer.</STRONG>  The file keeps only two 
    &quot;records&quot;, the &quot;even&quot; part and the &quot;odd&quot; 
    part (useful, for example, for &quot;restart&quot; files where you're 
    only interested in the last good data in the file).  The file's 
    description has a starting date, a starting time, and a negative 
    time step (set to the negative of the actual time step); read and 
    write requests must be for some positive integer multiple of the 
    time step from the starting date and time -- and must be for a 
    time step actually present -- or they will fail.
</UL>
There are eight <A HREF = "DATATYPES.html#struct"> structure-types </A> 
and three <A HREF = "DATATYPES.html#basic"> basic types </A> of data
supported by the I/O API.  The structure-types are associated with file type 
parameter values (&quot;magic numbers&quot;) <STRONG>CUSTOM3</STRONG>, 
<STRONG>DCTNRY3</STRONG>, <STRONG>GRDDED3</STRONG>, 
<STRONG>BNDARY3</STRONG>, <STRONG>IDDATA3</STRONG>, 
<STRONG>PROFIL3</STRONG>, <STRONG>GRNEST3</STRONG>, and 
<STRONG>SMATRX3</STRONG> (for which GRDDED3 and BNDARY3 will account for 
almost all CTM uses), which are defined in INCLUDE-file 
<A HREF = "INCLUDE.html">PARMS3.EXT</A>.  The basic types are associated 
with &quot;magic numbers&quot; <STRONG>M3INT</STRONG>, <STRONG>M3REAL</STRONG>,
and <STRONG>M3DBLE</STRONG>, also defined in INCLUDE-file PARMS3.EXT.
Each of these data types supports multiple time steps of multiple layers 
of multiple user-defined variables, as indicated below.  In some cases, 
there are additional system-defined variables which are part of the data 
structure (e.g., the <A HREF = "#numids"> <CODE>NUMIDS</CODE> in the 
ID-referenced data structure, below)</A> .  Where such system-defined 
variables are present, the operations READ3() and WRITE3() act on entire 
time steps (all variables) at once; otherwise, they can be used to store 
or retrieve time steps of individual variables one at a time.  There are 
moderate performance advantages to writing the variables for a time step 
in the same order that they appear in the file description, and for writing 
the time steps in consecutive order; however, this is not required by the 
I/O API (which permits any access order to the data, for both read and 
write operations).  The structural types are as follows, together with 
declarations for sample time step records of these data types:
(In the examples, declarations are given for M3REAL variables in terms 
of REAL*4, etc, instead of merely REAL, to protect you in the cases that 
your compiler has a &quot;-r8&quot; flag, etc., which silently changes all 
REALs from 4-byte to 8-byte -- and causes you accidentally to be linked 
with an incompatible version of the library; if you never use this flag, 
don't worry.)  The structure-types are:
<UL> 
    <LI>  <STRONG>CUSTOM3</STRONG> = -1:  
      custom data--this is just a user-dimensioned 
    array of REAL*4's that the system reads and writes reliably; it's 
    up to you to interpret its structure for yourself.  (This one 
    was included on the &quot;I probably haven't thought of everything&quot; 
    principle.)
<PRE>
        ...(SIZE is a fixed, user-defined dimension:)
        REAL*4  ARRAY( SIZE, NLAYS, NVARS )
</PRE>
    
    <LI>  <STRONG>DCTNRY3</STRONG> = 0:  
    dictionary--the reusable parts of a file description; 
    this data type is used as an aid to model management, to store and 
    retrieve the following parts of an
    <A HREF = "INCLUDE.html#fdesc"> FDESC3.EXT </A> file description:
<PRE>
        FTYPE3D, TSTEP3D, NCOLS3D, NROWS3D, NLAYS3D, NVARS3D, NTHIK3D,
        GDTYP3D, P_ALP3D, P_BET3D, P_GAM3D, XORIG3D, YORIG3D, XCELL3D, 
        YCELL3D, GDNAM3D, XCENT3D, YCENT3D, VNAME3D, UNITS3D, VDESC3D
</PRE>
    
    <LI>  <STRONG>GRDDED3</STRONG> = 1:  
    gridded data, dimensioned as in:
<PRE>
    REAL*4  ARRAY( NCOLS, NROWS, NLAYS, NVARS )
</PRE>

    <LI>  <STRONG>BNDARY3</STRONG> = 2:  
    boundary data for an external perimeter to a grid.  
    This perimeter is <CODE>NTHIK</CODE> cells wide (where you may use a 
    negative <CODE>NTHIK</CODE> to indicate an internal perimeter such as 
    is used by ROM and RADM).  The boundary array is dimensioned 
    as follows in terms of the dimensions NCOLS and NROWS for the array 
    it surrounds:
<PRE>
    ...(SIZE = ABS( NTHIK )*(2*NCOLS + 2*NROWS +4*NTHIK)
    REAL*4  ARRAY( SIZE, NLAYS, NVARS )
</PRE>
    There are accompanying diagrams illustrating the data layout for
    various cases of NTHIK:
    <UL>
        <LI> the general thickened-boundary case, NTHIK &gt; 1, available 
            as <A HREF = "THKBDY.ps"> Postscript</A>,
            as <A HREF = "THKBDY.xbm"> X11 Bitmap</A>,
            as <A HREF = "THKBDY.jpg"> JPEG</A>, or
            as <A HREF = "THKBDY.gif"> GIF</A>;
        <LI> the simple case, NTHIK = 1, available 
            as <A HREF = "BDY.ps"> Postscript</A>,
            as <A HREF = "BDY.xbm"> X11 Bitmap</A>,
            as <A HREF = "BDY.jpg"> JPEG</A>, or
            as <A HREF = "BDY.gif"> GIF</A>;
        <LI> the internal-boundary case, NTHIK = -1 (&lt; 0), available 
            as <A HREF = "INTBDY.ps"> Postscript</A>,
            as <A HREF = "INTBDY.xbm"> X11 Bitmap</A>,
            as <A HREF = "INTBDY.jpg"> JPEG</A>, or
            as <A HREF = "INTBDY.gif"> GIF</A>.
    </UL>

    <LI>  <STRONG><A NAME = "numids"> IDDATA3 </A></STRONG> = 3:  
    ID-referenced data, used to store lists of data 
    like surface meteorology observations, pollution-monitor observations, 
    or county-averaged concentrations.  (ROM people note:  this is 
    a generalization of ROM Type 2 and 3 files, except that if you 
    want the positions  and elevations, you have to list them as 
    variables yourself).  An example of observational data with up 
    to 100 sites, each measuring temperature, pressure, and relative 
    humidity (in addition to having an X-Y position) is the following:
<PRE>
    ...
    INTEGER*4   MAXID              !  max permitted # of sites
    PARAMETER ( MAXID = 100 )
    ...
    INTEGER*4   NUMIDS             !  number of actual sites
    INTEGER*4   IDLIST( MAXID )    !  list of site ID's
    REAL*4      XLON  ( MAXID )    !  first variable in file
    REAL*4      YLAT  ( MAXID )    !  second variable
    REAL*4      TK    ( MAXID )    !  third variable
    REAL*4      PRES  ( MAXID )    !  fourth variable
    REAL*4      RH    ( MAXID )    !  fifth (last) variable
    COMMON /FOO/ NUMIDS, IDLIST, XLON, YLAT, TK, PRES, RH
</PRE>    
    NVARS3D is 5.
    The dimension <CODE>MAXID</CODE> maps into the <CODE>NROWS3D</CODE> 
    dimension in the file description data structure <CODE>FDESC3.EXT,</CODE> 
    for use by OPEN3() or DESC3().  To read or write this data, put the 
    first element, <CODE>NUMIDS,</CODE> of  this common in the 
    <CODE>array</CODE> spot of READ3(), 
    WRITE3(), etc.:
<PRE>
    IF ( .NOT. WRITE3( 'myfile', 'ALL', JDATE, JTIME, NUMIDS ) ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
</PRE>
    
    <LI>  <STRONG>PROFIL3</STRONG> = 4:  
    vertical profile data (rawindsonde data), which 
    has a sufficiently different structure from other observational data
    (having possibly a site-dependent number of levels at each site)
    that it deserves a special data type of its own.  (This is much
    like ROM Type 1 files.)   An example of the  sort of data structure 
    needed for a rawinsonde file with NVARS3D = 3 variables <CODE>ELEV, 
    TA,</CODE> and  <CODE>QV</CODE> given at up to 50 stations, each of 
    which may have up  to 100 observation  levels, is given by the following.  
    Note that  <CODE>ELEV</CODE> = &quot;height of the level above ground&quot; 
    is user-specified as one of the variables rather than supplied by the
    system as for ROM Type 1 files.
<PRE>
    ...
    INTEGER*4   MXIDP             !  max # of sites
    INTEGER*4   MXLVL             !  max # of levels
    PARAMETER ( MAXID = 50, MXLVL = 100 )
    ...
    INTEGER*4   NPROF             !  # of actual sites
    INTEGER*4   PLIST( MXIDP )    !  list of site ID's
    INTEGER*4   NLVLS( MXIDP )    !  # of actual levels at site
    REAL*8      X    ( MXIDP )    !  array of site X-locations
    REAL*8      Y    ( MXIDP )    !  array of site Y-locations
    REAL*8      Z    ( MXIDP )    !  array of site Z-locations
    REAL*4      ELEV ( MXLVL, MXIDP )    !  height of lvl a.g.l.
    REAL*4      TA   ( MXLVL, MXIDP )    !  variable &quot;TA&quot;
    REAL*4      QV   ( MXLVL, MXIDP )    !  variable &quot;QV&quot;
    COMMON /BAR/ NPROF, PLIST, NLVLS, X, Y, Z, ELEV, TA, QV
    ...
</PRE>    
    The site dimension <CODE>MXIDP</CODE> maps into the <CODE>NROWS3D</CODE>
    dimension , and the  levels dimension <CODE>MXLVL</CODE> maps into the 
    <CODE>NCOLS3D</CODE> dimension in the  file description (FDESC3) data 
    structures.   To read or write  this data, put the first element, 
    <CODE>NPROF,</CODE> of the common BAR in the 
    <CODE>array</CODE> spot of READ3(), WRITE3(), etc.:
<PRE>
    IF ( .NOT. WRITE3( 'myfile', 'ALL', JDATE, JTIME, NPROF ) ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
</PRE>

    <LI>  <STRONG>GRNEST3</STRONG> = 5:  
    nested-grid data should be considered as a preliminary and
    experimental implementation for storing multiple grids, which need
    not in fact have any particular relationship with each other beyond
    using the same coordinate system.  An example of the  sort of data
    structure needed for a nest of grids for the NVVARS3D = 2 variables 
    NO2 and O3 is the following:
<PRE>
    ...
    INTEGER*4   MXNEST            !  max # of nests
    INTEGER*4   MXGRID            !  max # of cells (total, all grids)
    INTEGER*4   MXLAYS            !  max # of levels
    PARAMETER ( MXNEST = 10, MXGRID = 10000, MXLAYS = 25 )
    ...
    INTEGER*4   NNEST              !  # of actual nests
    INTEGER*4   NLIST( MXNEST )    !  list of nest ID's
    INTEGER*4   NCOLS( MXNEST )    !  # of actual cols of nest
    INTEGER*4   NROWS( MXNEST )    !  # of actual rows of nest
    INTEGER*4   NLAYS( MXNEST )    !  # of actual lays of nest
    REAL*8      XN   ( MXNEST )    !  array of nest X-locations
    REAL*8      YN   ( MXNEST )    !  array of nest Y-locations
    REAL*8      DX   ( MXNEST )    !  array of nest cell-size DX's
    REAL*8      DY   ( MXNEST )    !  array of nest cell-size DY's
    REAL*4      NO2  ( MXGRID, MXLAYS, MXNEST )    !  variable &quot;NO2&quot;
    REAL*4      O3   ( MXGRID, MXLAYS, MXNEST )    !  variable &quot;O3&quot;
    COMMON /QUX/ NNEST, NLIST, NCOLS, NROWS, NLAYS, 
 &amp;               XN, YN, DX, DY, NO2, O3
    ...
</PRE>
    The nest dimension <CODE>MXNEST</CODE> maps into the <CODE>NROWS3D</CODE> 
    dimension, the cells  dimension <CODE>MXGRID</CODE> maps onto 
    <CODE>NCOLS3D,</CODE> and the layers dimension <CODE>MXLAYS</CODE> 
    maps onto <CODE>NLAYS3D</CODE> in the file description (FDESC3) data
    structures.   To read or write this data, put the first element, 
    <CODE>NNEST,</CODE> of this  common <CODE>QUX</CODE> in the 
    <CODE>ARRAY</CODE> spot of READ3(), WRITE3(), etc.:
<PRE>
    IF ( .NOT. WRITE3( 'nfile', 'ALL', JDATE, JTIME, NNEST ) ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
</PRE>

    <LI>  <STRONG>SMATRX3</STRONG> = 6:  
    sparse matrix data, which uses a &quot;skyline-transpose&quot;
    representation for sparse matrices, such as those found in the
    emissions model prototype.  An example of the sort of data
    structure needed for these sparse matrices is the following:
<PRE>
    ...
    INTEGER     NASRC   !  max # of active cols per row
    INTEGER     NGRID   !  number of rows in the matrix
    PARAMETER ( NASRC = 3978, NGRID = 5400 )
    ...
    INTEGER     NS( NGRID )         !  # of actual cols per row
    INTEGER     IS( NACEL , NGRID ) !  column pointers
    REAL        CS( NACEL , NGRID ) !  col-coefficients
            
    COMMON  / GRIDMAT / NS, IS, CS
</PRE>
    In this case, NVARS3D = 1.  In the case of 
    NVARS3D &gt; 1, multiple
    coefficient matrices would share the same NS and IS arrays.
    The active-columns dimension NASRC maps into the NCOLS3D dimension
    and the matrix-rows dimension NGRID maps into the NROWS3D dimension
    in the file description (FDESC3) data structures.   To read or
    write this data, put the first element, <CODE>NS</CODE> of the common 
    <CODE>GRIDMAT</CODE> in the <CODE>array</CODE> spot of READ3(), 
    WRITE3(),etc.:
<PRE>
    IF ( .NOT. WRITE3( 'mfile', 'ALL', JDATE, JTIME, NS ) ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
</PRE>
</UL>    

The include-file 
<A HREF = "INCLUDE.html#fdesc"><STRONG>FDESC3.EXT</STRONG> </A> 
contains heavily annotated declarations for all the variables in a 
file description, together with the two commons which are used by the 
I/O API to store and retrieve the file descriptions.  The DESC3() routine 
takes a file and puts its description into the FDESC3 commons; OPEN3() 
does roughly the reverse when dealing with new or unknown files, taking a 
description from the FDESC3 commons and building a new file according to 
those specifications, or performing a consistency check with the 
description stored in the file's header.  A typical call to 
<A HREF = "DESC3.html"> DESC3() </A> might look like:
<PRE>
        ..
        IF ( .NOT. DESC3( 'myfile' ) ) THEN
        ...(error:  probably the file hasn't been opened yet)
        END IF
</PRE>
    
Some of the items in a file description, such as the dates and times 
for file creation and update, and the name of the program which created 
the file, are maintained automatically by the system.  Others describe 
the variables in the file:  the file type (as described above), the 
number of variables, their names, unit designations, and descriptions, 
as well as the description of the file as a whole.  Still others 
dimension the data:  the number of layers and the grid dimensions 
(where for ID and profile files, the number of sites is mapped onto 
the rows dimension; for profile files, the number of vertical levels 
is mapped onto the columns dimension).  Still other parts of the file 
description specify the geometry of the grid:  the map projection used, 
its projection parameters, and the grid's location and cell-size 
relative to that map projection; the vertical-grid-coordinate type 
and the boundary values separating the model layers.


     <H2> <A NAME = "start"> 
     How to Start Up and Shut Down the I/O API 
     </A> </H2>

In order for the I/O API to start itself up correctly, and in order to 
make sure that files are closed (and that file headers are updated) 
correctly, you need to call the INIT3() function at the start of your 
program, and the SHUT3() function (which flushes headers for, and 
closes <EM>all</EM> files currently open) at the end, or else the CLOSE3()
function for each file opened.  Note that the utility routines 
<A HREF = "M3ERR.html"> M3ERR() </A> and
<A HREF = "M3EXIT.html"> M3EXIT()</A>, when used to shut down
a program, will call SHUT3() correctly (as well as writing explanatory
messages to the log).
<P> 

<A HREF = "INIT3.html"> <STRONG>INIT3()</STRONG> </A> is an integer 
function.  It returns the unit number to be used 
for the program's log (if you setenv <CODE>LOGFILE</CODE>, the I/O API's log and 
error messages will be written to this unit; otherwise, they go to 
standard output, unit 6).  INIT3() can be called as many times as you 
want, to get the unit number for the program log.
<P> 

<A HREF = "SHUT3.html"> <STRONG>SHUT3()</STRONG> </A> is a logical 
function that returns TRUE if the system successfully flushed all I/O API
files to disk and shut itself down, and FALSE if it failed.  If it failed, 
there probably was a hardware problem -- not much you can do about it, but 
at least you ought to be able to know.  It is legal to call SHUT3()
and close down all files currently open, and then to call INIT3() again
and open new ones.  <STRONG>NOTE</STRONG> that utility routine 
<A HREF = "M3EXIT.html">M3EXIT()</A> calls SHUT3() as the final step
of its operation (in addition to generating a log-message with the 
current simulation date-and-time and the indicated message-text).

<A HREF = "CLOSE3.html"> <STRONG>CLOSE3()</STRONG> </A> is a logical 
function that returns TRUE if the system successfully flushed the 
indicated file to disk and closed it, and FALSE if it failed.


     <H2> <A NAME = "open"> 
     How to Open (Create) and Get Descriptive Info About Files 
     </A> </H2>

<A NAME = "open"> Use 
</A> <A HREF = "OPEN3.html"> <STRONG>OPEN3()</STRONG> </A> 
to open files, whether files that already exist or files that are new.  
OPEN3() is a logical function that return TRUE when it succeeds, and 
FALSE when it fails.  It also maintains much audit trail information 
stored in the file header automatically, and automates various logging 
activities.  A couple of additional pieces of audit trail information 
requires a bit of work from you in setting up 
<A HREF = "ENVIRONMENT.html">standard environment variables</A>, if 
you want to take advantage of it:  if you define 
the description of your program run in a text file of up to 60 lines of 
up to 80 characters each, and then <CODE>setenv SCENFILE</CODE> to that 
file before you run the program, then OPEN3 will copy the 
<CODE>SCENFILE</CODE> information into the headers of any output files 
for that program.  Also, if you <CODE>setenv EXECUTION_ID</CODE> to your 
own identifier for the program execution, it will automate the storage 
and the logging of that identifier.  Finally, if you <CODE>setenv
IOAPI_CHECK_HEADERS YES</CODE>, then the I/O API will perform a sanity
check on internal file descriptions -- checking that grid description
parameters are in range, for example, or that vertical levels are
either systematically increasing or systematically decreasing.
<P> 

The arguments to OPEN3 are the name 
of the file, an <CODE>INTEGER</CODE> &quot;magic number&quot; indicating 
the type of open operation, and the caller's name for logging and 
audit-trail purposes.  You can call OPEN3 many times for the same file 
without hurting anything, if you want -- as long as you don't first open 
it read-only and then try to change your mind, or try to open it as a 
NEW file after it is already open.  Names and values for the 
mode-of-opening magic number argument are defined in 
<A HREF = "INCLUDE.html#parms"> <STRONG>PARMS3.EXT</STRONG> </A> as 
the following:
<UL>
    <LI>  <STRONG>FSREAD3</STRONG> = 1 for READ-ONLY access to 
          an existing file 
    
    <LI>  <STRONG>FSRDWR3</STRONG> = 2 for READ/WRITE/UPDATE access 
          to an existing file 

    <LI>  <STRONG>FSNEW3</STRONG> = 3 for READ/WRITE access to create 
          a new file (file must not yet exist); or 
    
    <LI>  <STRONG>FSUNK3</STRONG> = 4 for READ/WRITE/UPDATE access to a file 
          whose existence is unknown (creates the file if it does not 
          yet exist, otherwise, performs consistency check with the 
          user-supplied file definition).

    <LI>  <STRONG>FSCREA3</STRONG> = 5 for CREATE/TRUNCATE/READ/WRITE 
          access to files.  If the file is open, close it.  If the file
          exists, delete it.  Then create a new file according to the
          user-supplied file definition.

</UL>

In the last three cases, &quot;new&quot; &quot;unknown&quot; and 
&quot;create/truncate,&quot; you fill in the file description from 
the <CODE>INCLUDE</CODE> file 
<STRONG><A HREF = "INCLUDE.html#fdesc"> FDESC3.EXT </A></STRONG> 
to define the structure for the file, and then call OPEN3().  If the 
file doesn't exist in either of these cases, OPEN3() will use the 
information to create a new file according to your specifications, 
and open it for read/write access.  In the &quot;unknown&quot;case, 
if the file already exists, OPEN3() will perform a consistency check 
between your supplied file description and the description found in 
the file's own header, and will return TRUE (and leave the file open) 
only if the two are consistent.  Sample calls to OPEN3() for an 
input file 'myfile' and an output file 'my_newfile' might look like 
the following:
<PRE>
    ...
    IF ( .NOT OPEN3( 'myfile', FSREAD3, 'my program') ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
    ...
    ...  (First, fill in the file's description for 'my_newfile'.
    ...   Then open it:)
    IF ( .NOT. OPEN3( 'my_newfile', FSNEW3, 'my program' ) ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
</PRE>
There are also <A HREF = "SAMPLE.html">three sample programs</A> that
demonstrate how to use the I/O API to create various kinds of files --
gridded, boundary, and ID-referenced, with one or multiple layers, and
either time-stepped or time-independent.
<P> 
    
    <STRONG>NOTE: </STRONG> Joan Novak (EPA)  and Ed Bilicki (MCNC) 
    have declared as a software standard that <STRONG>modeling programs 
    may not  use FSCREA3 as the mode for opening files.</STRONG>  
    FSCREA3 is reserved for use by analysis/data extraction programs
    only.
    <P> 

<A NAME = "desc"> To </A> get a file's description, you use the 
<A HREF = "DESC3.html"> <STRONG>DESC3()</STRONG> </A> function.  
When you call DESC3(), it puts the file's complete description in the 
standard file description data structures in 
<CODE><A HREF = "INCLUDE.html#fdesc"> FDESC3.EXT </A>.</CODE>  
Note that the file must have been opened prior to calling DESC3().  
A typical call might look like:
<PRE>        
    ...
    IF ( .NOT. DESC3( ' myfile' ) ) THEN
    ...(some kind of error happened--deal with it here)
    ELSE
    ...(the FDESC3 commons now contain the file description:
    ... data type, dimensions, starting date&amp;time, timestep, 
    ... list of variables and their descriptions, etc.)
    END IF
    ...
</PRE>


     <H2> <A NAME = "read"> 
     How to Read Data from Files 
     </A></H2>

There are four routines with varying kinds of selectivity used to read 
or otherwise retrieve data from files:  
<A HREF = "READ3.html">     READ3()</A> , 
<A HREF = "XTRACT3.html"> XTRACT3()</A> , 
<A HREF = "INTERP3.html"> INTERP3()</A> , and 
<A HREF = "DDTVAR3.html"> DDTVAR3()</A>.  All of 
them are logical functions that return TRUE when they succeed, FALSE when 
they fail.  
<UL>    
    <LI>  <STRONG>READ3()</STRONG> reads one or all variables and layers 
          from a file for a particular date and time;
    
    <LI>  <STRONG>XTRACT3()</STRONG> reads a windowed subgrid for one or 
          all variables from a file for a particular date and time; 
    
    <LI>  <STRONG>INTERP3()</STRONG> interpolates the requested variable 
          from the requested file to the requested date and time
          (optimizing disk accesses and interpolation-buffer manipulation
          internally behind the scenes); and 
    
    <LI>  <STRONG>DDTVAR3()</STRONG> computes the time-derivative 
          (per second) of the requested  variable at the specified 
          date and time.  
</UL>

The first two require that the time step you request be on the file -- 
they won't give you data for the half-hour, for example, if the file has 
hourly data only.  Because it optimizes the interpolation problem for
you, INTERP3 is probably the most useful of these.  Note that it has a 
<CODE>size</CODE> argument -- you tell it how much data you expect, and 
it checks that against how much data the file thinks you ought to get, 
for error checking purposes.  A typical INTERP3 call to read/interpolate 
the variable HNO3 to 12:30 PM on February 4, 1987 might look like:
<PRE>
        ...
        CHARACTER*16 FNAME, VNAME
        REAL*4       ARRAY( NCOLS, NROWS, NLAYS )
        ...
        IF ( .NOT. INTERP3( 'myfile', 'HNO3', 1987035, 123000,
        &amp;                   NCOLS*NROWS*NLAYS, ARRAY ) ) THEN
        ...(some kind of error happened--deal with it here)
        END IF
</PRE>
With READ3() and XTRACT3(), you can use the 
<A HREF = "INCLUDE.html#magic"> &quot;magic values&quot;  </A>
<CODE>ALLVAR3'</CODE> (= 'ALL', defined in 
<A HREF = "INCLUDE.html#parms"> <CODE>PARMS3.EXT</CODE> </A>) or
<CODE>ALLAYS3</CODE> (= -1, also defined in <CODE>PARMS3.EXT</CODE>) as 
variable name and/or layer number 
to read all variables or all layers from the file, respectively.  
For time independent files, the date and time arguments are ignored.


     <H2>  <A NAME = "write"> 
     How to Write Data to Files
     </A> </H2>

You use the logical function 
<A HREF = "WRITE3.html"> <STRONG>WRITE3()</STRONG> </A> 
to write data to files.  For gridded, boundary, and custom files, you 
may write either one time step of one variable at a time, or one entire 
time step of data at a time (in which case, use 
<A HREF = "INCLUDE.html#magic"> &quot;magic value&quot; </A>
<CODE>ALLVAR3</CODE> (= 'ALL', defined in 
<A HREF = "INCLUDE.html#parms"> <CODE>PARMS3.EXT</CODE> </A>) as the 
variable-name.  For ID-referenced, 
profile, and grid-nest files, you must write an entire time step at a time
(i.e., the variable-name <EM>must</EM> be <CODE>ALLVAR3</CODE>).
WRITE3() is affected by <A HREF = "ENVIRONMENT.html">standard
environment variable IOAPI_LOG_WRITE</A> (which has default value
&quot;YES&quot;); normally WRITE3() generates a log message for each
write-operation successfully completed.  However, if you 
<CODE>setenv&nbsp;IOAPI_LOG_WRITE&nbsp;NO</CODE> then these messages will be
suppressed.  Typical WRITE3() calls to write data for date and time 
JDATE:JTIME might look like the following:
<PRE>
    ...
    REAL*4       ARRAY( NCOLS, NROWS, NLAYS, NVARS )
    ...
    IF ( .NOT. WRITE3( 'myfile', 'HNO3', JDATE, JTIME, ARRAY ) ) THEN
    ...(some kind of error happened--deal with it here)
    END IF
    IF ( .NOT. WRITE3( 'afile', 'ALL', JDATE, JTIME, ARRAYB ) )  THEN
    ...(some kind of error happened--deal with it here)
    END IF
</PRE>
   

     <H2> <A NAME = "conventions"> 
     How to Manipulate Dates and Times, and Other Conventions 
     </A> </H2>

Throughout the EDSS and Models-3 systems -- and particularly in the 
I/O API -- <A HREF = "DATETIME.html"> dates and times </A> 
(and time-steps) are stored as integers, using the coding formats
<PRE>
    HHMMSS  = 10000 * hour  +  100 * minutes  +  seconds
    YYYYDDD =  1000 * year  +  day
</PRE>       
where the year is 4-digits (1994, say, rather than just 94), and the
day is the Julian day-number (1,...,365 or 366).  By convention, 
dates and times are <STRONG>stored in Greenwich Mean Time.</STRONG>  
There are two utility programs, <A HREF = "JULDATE.html"> 
<STRONG>juldate</STRONG></A>, for converting calendar dates to Julian 
dates, and <A HREF = "GREGDATE.html"> <STRONG>gregdate</STRONG></A>, 
for converting Julian dates to calendar dates and reporting the 
day-of-the-week.  Both of these programs also report whether daylight
savings time is in effect for  the specified date.  There are also a
number of utility routines available for manipulating dates and times.  
Note that for these routines, time steps may perfectly well be 
negative -- just make sure you keep the parts all positive or 
all negative; a time step of  -33000  means to step three and a half 
hours into the past, for example.  This way of representing dates and 
times is easy to understand and manipulate when you are watching code 
in the debugger (you don't have to turn &quot;seconds since Jan. 1, 1970&quot; 
into something meaningful for your model run, nor do you have to remember 
whether April has 30 days or 31 when your model run crosses over from 
April to May).  The utility routines for manipulating dates and times 
are the following:
<UL>
    <LI>  <A HREF = "NEXTIME.html"> 
          <STRONG>NEXTIME( JDATE, JTIME, TSTEP )</STRONG> </A>  
          is a subroutine which updates date and time JDATE:JTIME by the  
          time step TSTEP (which may be either positive or negative); 

    <LI>  <A HREF = "TIME2SEC.html"> 
          <STRONG>TIME2SEC( TSTEP )</STRONG> </A> is an integer function 
          which returns the number of seconds in the time interval TSTEP; 

    <LI>  <A HREF = "SEC2TIME.html"> <STRONG>SEC2TIME( SECS )</STRONG> </A> 
          is an  integer function which returns the time interval HHMMSS 
          for the specified number of seconds; 

    <LI>  <A HREF = "SECSDIFF.html"> 
          <STRONG>SECSDIFF( ADATE, ATIME, ZDATE, ZTIME )</STRONG> </A> 
          is an integer function which returns the number of seconds 
          from ADATE:ATIME to ZDATE:ZTIME; 

    <LI>  <A HREF = "DT2STR.html"> 
          <STRONG>DT2STR( JDATE, JTIME )</STRONG> </A> is a  
          CHARACTER*24 utility function which returns a CHARACTER*24 
          string  for the date and time, as for example 
          &quot;09:12:25 April 28, 1994&quot;

    <LI>  <A HREF = "CURRSTEP.html"> 
          <STRONG>CURREC( JDATE, JTIME, SDATE, STIME, TSTEP,
          CDATE, CTIME )</STRONG> </A> is an INTEGER function which returns
          the record number for the time step that contains
          <VAR>JDATE:JTIME</VAR> in the time step sequence
          <VAR>SDATE:STIME:TSTEP</VAR>, even if <VAR>JDATE:JTIME</VAR> 
          is not an exact time step, and sets <VAR>CDATE:CTIME</VAR> to
          the exact date&amp;time for this time step sequence.  If
          <VAR>JDATE:JTIME</VAR> is before <VAR>SDATE:STIME</VAR>,
          returns -1.

    <LI>  <A HREF = "HHMMSS.html"> <STRONG>HHMMSS( JTIME )</STRONG> </A> 
          is a CHARACTER*10 utility function which returns the 
          CHARACTER*10 string for the time &quot;HH:MM:SS&quot; 
          (like the first field from DT2STR); 

    <LI>  <A HREF = "ISDSTIME.html"> <STRONG>ISDSTIME( JDATE )</STRONG> </A> 
          is a LOGICAL utility function which returns TRUE
          when daylight savings time is effect for <VAR>JDATE</VAR>

    <LI>  <A HREF = "JSTEP3.html"> <STRONG>JSTEP3( JDATE, JTIME, SDATE, STIME, TSTEP )</STRONG> </A> 
          is an INTEGER function which returns the timestep-record
          number corresponding to JDATE:JTIME if JDATE:JTIME is exactly
          on the timestep sequence, or -1 otherwise.

    <LI>  <A HREF = "MMDDYY.html"> <STRONG>MMDDYY( JDATE )</STRONG> </A> 
          is a CHARACTER*14  utility function which returns a  
          CHARACTER*14 string &quot;Month DD, YYYY&quot; 
          for the date (like the second field from DT2STR); 

    <LI>  <A HREF = "DAYMON.html"> 
          <STRONG>DAYMON( JDATE, MONTH, MDAY )</STRONG> </A>  is a 
          utility subroutine which returns the month (1, ..., 12) and  
          day of month (1, ..., 31) for the specified Julian date; 

    <LI>  <A HREF = "WKDAY.html"> <STRONG>WKDAY( JDATE )</STRONG> </A> 
          is a utility  integer function which returns the day-of-week 
          (1, ..., 7) for the  specified Julian date; 

    <LI>  <A HREF = "JULIAN.html"> 
          <STRONG>JULIAN( YYYY, MONTH, MDAY )</STRONG> </A>  
          is a utility integer function which returns the Julian day  
          (1, ...,  366) for a specified year, month (1-12), and 
          day of month (1-31).

</UL><P> 

    
Diagrams showing the relationship of the grid and its layers to the
header attributes XORIG3D, YORIG3F, VGLVS3D, etc., are available in 
<A HREF = "3D.ps">Postscript</A>, 
<A HREF = "3D.xbm">X bitmap</A>,
<A HREF = "3D.jpg">JPEG</A>, and
<A HREF = "3D.gif">GIF</A> image formats.  Note that Layer 1
is the  bottom layer in the modeling grid.   Some development 
work needs yet to be done:  we need to do some more work 
about the definition of <A HREF = "GRIDS.html#horiz"> grids and 
map projections </A>, and then to define and write utility routines 
having to do with map projections, transformation of locations from 
one map projection to another, and interpolation of data from one 
grid to another (on possibly different map projections).
<P> 



<HR> <!----------------------------------------------------------------->
        
<A HREF = "AA.html#intro" >
Previous:  <STRONG>I/O Introduction Chapter</STRONG>
</A><P> 

<A HREF = "CHANGES.html" >
Next:  <STRONG>Changes from the Previous I/O API Version</STRONG>
</A><P> 

<A HREF = "SAMPLE.html" >
Related:  <STRONG>Sample Programs</STRONG>
</A><P> 

<A HREF = "AA.html"> 
To: <STRONG>Models-3/EDSS I/O API:   The Help Pages</STRONG> 
</A><P>


<!--#include virtual="/INCLUDES/footer.html" -->
                
</BODY>
</HTML>


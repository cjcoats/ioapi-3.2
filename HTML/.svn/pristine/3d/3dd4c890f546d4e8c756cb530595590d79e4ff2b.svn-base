
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- "$Id$" -->
<META NAME="MSSmartTagsPreventParsing" CONTENT="TRUE"> 
<TITLE> LOCAT*() </TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF" 
      TOPMARGIN="15" 
      MARGINHEIGHT="15" 
      LEFTMARGIN="15" 
      MARGINWIDTH="15">
<H1>    The LOCAT Routines </H1>


<H2> Fortran version: </H2>

<STRONG>Generic version for I/O&nbsp;API-3.2:</STRONG>  compiler selects the appropriate
type-specific form depending upon the number and types of the keys and
key-lists:

<PRE>
    INTEGER FUNCTION LOCATE( KEY1[,...,] N, LIST1[,...] )
        INTEGER  N              !   table size
        &lt;type&gt;   KEY1[, ...]
        &lt;type&gt;   LIST1(N)[, ...]
</PRE><P> 

<STRONG>Type-specific forms:</STRONG>
<PRE>
    INTEGER FUNCTION LOCATC( KEY,N, LIST )

    INTEGER FUNCTION LOCAT1( K1, N, LIST1 )
    INTEGER FUNCTION LOCAT2( K1, K2, N, LIST1, LIST2 )
    INTEGER FUNCTION LOCAT3( K1, K2, K3, N, LIST1, LIST2, LIST3 )
    INTEGER FUNCTION LOCAT4( K1, K2, K3, K4, 
 &amp;                          N, LIST1, LIST2, LIST3, LIST4 )

    INTEGER FUNCTION LOCATL1( L1, N, LLST1 )
    INTEGER FUNCTION LOCATL2( L1, L2, N, LLST1, LLST2 )
    INTEGER FUNCTION LOCATL3( L1, L2, L3, N, LLST1, LLST2, LLST3 )
    INTEGER FUNCTION LOCATL4( L1, L2, L3, L4, 
 &amp;                          N, LLST1, LLST2, LLST3, LLST4 )

    INTEGER FUNCTION LOCATR1( X1, N, XLST1 )
    INTEGER FUNCTION LOCATR2( X1, X2, N, XLST1, XLST2 )
    INTEGER FUNCTION LOCATR3( X1, X2, X3, N, XLST1, XLST2, XLST3 )
    INTEGER FUNCTION LOCATR4( X1, X2, X3, X4, 
 &amp;                          N, XLST1, XLST2, XLST3, XLST4 )

        CHARACTER*(*), INTENT(IN   ) :: KEY           !  key string
        INTEGER      , INTENT(IN   ) :: K1            !  first  key
        INTEGER      , INTENT(IN   ) :: K2            !  second key
        INTEGER      , INTENT(IN   ) :: K3            !  third  key
        INTEGER      , INTENT(IN   ) :: K4            !  fourth key
        INTEGER(8)   , INTENT(IN   ) :: L1            !  first  Ley
        INTEGER(8)   , INTENT(IN   ) :: L2            !  second Ley
        INTEGER(8)   , INTENT(IN   ) :: L3            !  third  Ley
        INTEGER(8)   , INTENT(IN   ) :: L4            !  fourth Ley
        REAL         , INTENT(IN   ) :: X1            !  first  key
        REAL         , INTENT(IN   ) :: X2            !  second key
        REAL         , INTENT(IN   ) :: X3            !  third  key
        REAL         , INTENT(IN   ) :: X4            !  fourth key
        INTEGER      , INTENT(IN   ) :: N             !  table size
        CHARACTER*(*), INTENT(IN   ) :: CLIST( N )    !  table to search for KEY
        INTEGER      , INTENT(IN   ) :: LIST1( N )    !  table to search for K1
        INTEGER      , INTENT(IN   ) :: LIST2( N )    !  table to search for K2
        INTEGER      , INTENT(IN   ) :: LIST3( N )    !  table to search for K3
        INTEGER      , INTENT(IN   ) :: LIST4( N )    !  table to search for K4
        INTEGER(8)   , INTENT(IN   ) :: LLST1( N )    !  table to search for L1
        INTEGER(8)   , INTENT(IN   ) :: LLST2( N )    !  table to search for L2
        INTEGER(8)   , INTENT(IN   ) :: LLST3( N )    !  table to search for L3
        INTEGER(8)   , INTENT(IN   ) :: LLST4( N )    !  table to search for L4
        REAL         , INTENT(IN   ) :: XLST1( N )    !  table to search for X1
        REAL         , INTENT(IN   ) :: XLST2( N )    !  table to search for X2
        REAL         , INTENT(IN   ) :: XLST3( N )    !  table to search for X3
        REAL         , INTENT(IN   ) :: XLST4( N )    !  table to search for X4
</PRE><P> 

<H2> C version:   </H2>
<PRE>
    int locat1c( int        k1,
                int        n,
                const int *list1 ); /** look up integer in sorted key table **/

    int locat2c( int        k1,
                int        k2,
                int        n, 
                const int *list1 ,
                const int *list2 ) ; /** look up &lt;K1,K2&gt; in 2-key table **/

    int locat3c( int        k1,
                int        k2,
                int        k3,
                int        n, 
                const int *list1 ,
                const int *list2 ,
                const int *list3 ) ; /** look up &lt;K1,K2,K3&gt; in 3-key table **/

    int locat4c( int        k1,
                int        k2,
                int        k3,
                int        k4,
                int        n, 
                const int *list1 ,
                const int *list2 ,
                const int *list3 ,
                const int *list4 ) ; /* look up &lt;K1,K2,K3,K4&gt; in 4-key table */

    int locatr1c( float        x1,
                 int          n,
                 const float *xlst1 ); /** look up float in sorted key table **/

    int locatr2c( float        x1,
                 float        x2,
                 int          n, 
                 const float *xlst1 ,
                 const float *xlst2 ) ; /** look up &lt;X1,X2&gt; in 2-key table **/

    int locatr3c( float        x1,
                 float        x2,
                 float        x3,
                 int          n, 
                 const float *xlst1 ,
                 const float *xlst2 ,
                 const float *xlst3 ) ; /** look up &lt;X1,X2,X3&gt; in 3-key table **/

    int locatr4c( float        x1,
                 float        x2,
                 float        x3,
                 float        x4,
                 int          n, 
                 const float *xlst1 ,
                 const float *xlst2 ,
                 const float *xlst3 ,
                 const float *xlst4 ) ; /* look up &lt;X1,X2,X3,X4&gt; in 4-key table */

</PRE><P> 

<H2> Summary: </H2>

    Return <STRONG>subscript</STRONG> at which the target character-string, integer, or
    real key-tuple <STRONG>should be inserted</STRONG> into a sorted 
    key-tuple table, or negative number -1 in case the key is already present.
    <P> 

    Fortran version returns Fortran subscript (1, ..., N); C version returns
    C subscript (0, ..., N-1).
    <P>

    For Fortran-90 generic <CODE>LOCATE()</CODE>, declarations and
    interface checking:    
    <PRE>
    <A HREF = "M3UTILIO.html">USE M3UTILIO</A>
    </PRE><P>
    
    <STRONG>See also </STRONG>
    <BLOCKQUOTE>
    <A HREF = "SORTI.html">SORTIC, SORTI1, SORTI2, SORTI3, 
    SORTI4, SORTR1, SORTR2, SORTR3, SORTR4</A> for sorting key-tuple 
    tables, and <BR>
    <A HREF = "FINDS.html">FINDCC, FINDC1, FINDC2, FINDC3, 
    FINDC4, FINDCR1, FINDCR2, FINDCR3, FINDCR4</A> for determining
    where to find entries in sorted  key-tuple tables.
    </BLOCKQUOTE>
    <P>


<H2> Preconditions:   </H2>

    <CODE>#include &quot;iodecl3.h&quot;</CODE> for C.
    <P> 
    
    Table &lt;N, LIST1, ... &gt; to be searched is sorted in increasing 
    order and does not have duplicates.
<P> 


<H2> Fortran Usage: </H2>
<PRE>
    ...
    USE M3UTILIO
    ...
    INTEGER       KEY
    INTEGER       I
    INTEGER       LIST1( 10 )
    DATA          LIST1 / 1980, 1983, 1985, 1988, 1990 /
    ...
    I = LOCAT1( KEY, 5, LIST1 )
    IF ( I .EQ. -1 ) THEN
        ... KEY already present in LIST1
    ELSE
        .... KEY would insert at location I for expanded table LIST1
    END IF
    ...
</PRE><P> 

<H2> C Usage: </H2>
<PRE>
    ...
    #include &quot;iodecl3.h&quot;                          
    ...
    int  k1, k2, k3, k4 ;
    int  indx ;
    ...
    if ( -1 == ( indx = locat4( k1, k2, k3, k4, 
                                tablesize, 
                                list1, list2, list3, list4 ) ) )
        {
        /** &lt;K1,K2,K3,K4&g already present **/
        ...
        }
    else{
        /** &lt;K1,K2,K3,K4&g belongs at subscript indx  **/
        ...
        }
    ...
</PRE><P> 


<HR>

<A HREF = "LEN2.html" >
Previous:  <STRONG>LEN2</STRONG>
</A><P> 

<A HREF = "LUSTR.html" >
Next:  <STRONG>LUSTR</STRONG>
</A><P> 

<A HREF = "AA.html#utility"> 
Up: <STRONG>Utility Routines</STRONG> 
</A><P>

<A HREF = "FINDS.html"> 
SEE ALSO: <STRONG><CODE>FIND*</CODE> Binary Search Routines</STRONG> 
</A><P>

<A HREF = "SORTI.html"> 
SEE ALSO: <STRONG><CODE>LOCAT*</CODE>Sort Routines</STRONG> 
</A><P>

<A HREF = "AA.html"> 
To: <STRONG>Models-3/EDSS I/O API:   The Help Pages</STRONG> 
</A><P>

</BODY>
</HTML>


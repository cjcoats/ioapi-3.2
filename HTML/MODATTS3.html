
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<!-- "$Id: MODATTS3.html 311 2016-02-10 19:21:29Z coats $" -->
<META NAME="MSSmartTagsPreventParsing" CONTENT="TRUE">
<TITLE>MODULE MODATTS3</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF"
      TOPMARGIN="15"
      MARGINHEIGHT="15"
      LEFTMARGIN="15"
      MARGINWIDTH="15">

<!--#include virtual="/INCLUDES/header.html" -->

<H1>    Fortran-90 <CODE>MODULE MODATTS3</CODE> </H1>

<EM>New for I/O&nbsp;API-3.2!!</EM>  Developed from (and extends) I/O&nbsp;API-3.1
<CODE>MODULE MATXATTS</CODE>.

<H2>Summary</H2>

    <BLOCKQUOTE>
    Fortran-90 style <CODE>MODULE MODATTS3</CODE> uses the I/O&nbsp;API
    &quot;extra-attributes&quot; interface to provide CF-compliant
    <A HREF="http://cfconventions.org/">CF-convention</A> geospatial
    metadata, and CMAQ-standard, and SMOKE-standard metadata for newly-created
    I/O&nbsp;API files and input-grid and output-grid metadata for
    I/O&nbsp;API matrix-files, in terms of <A HREF="GRIDS.html#horiz">
    Models-3 I/O&nbsp;API map projection and grid description
    conventions.</A>
    <P>
    Note that adding metadata to a file to which data have already been
    written may entail substantial overhead (both of time and
    disk-space):  the &quot;system&quot; will have to make a new copy of
    the file with the new metadata and the existing data, and then
    rename it behind the scenes.
    <P>
    </BLOCKQUOTE>

<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="contents">
Contents of <CODE>MODULE MODATTS3</CODE>
</A></H3>

    <BLOCKQUOTE>
    <DL>
        <DT> <CODE>LOGICAL, PUBLIC, PROTECTED :: CFMETA</CODE>
        <DD> <CODE>TRUE</CODE> if and only if CF-metadata is
             turned on, and available in the module
             <P>
        <DT> <CODE>LOGICAL, PUBLIC, PROTECTED :: MATXMETA</CODE>
        <DD> <CODE>TRUE</CODE> if and only if matrix-metadata is
             turned on, and available in the module
             <P>
        <DT> <CODE>LOGICAL, PUBLIC, PROTECTED :: CMAQMETA</CODE>
        <DD> <CODE>TRUE</CODE> if and only if CMAQ-metadata is
             turned on, and available in the module
             <P>
        <DT> <CODE>LOGICAL, PUBLIC, PROTECTED :: SMOKEMETA</CODE>
        <DD> <CODE>TRUE</CODE> if and only if SMOKE-metadata is
             turned on, and available in the module<BR>
             <EM>SMOKE-metadata is not yet implemented, and
             may never be ;-( </EM>
             <P>
        <DT> &nbsp;

        <DT> <CODE>TYPE CMETA_T</CODE>
        <DD> Derived data type for standard CMAQ metadata objects.<BR>
             The fields are the following:
             <DL>
                <DT><CODE>INTEGER :: VERSION3</CODE>
                <DD>Version-number for the CMAQ-metadata data dictionary

                <DT><CODE>CHARACTER*32 :: PROJECT</CODE>
                <DD>Current modeling-project name

                <DT><CODE>CHARACTER*32 :: CASE</CODE>
                <DD>Current modeling-case name

                <DT><CODE>CHARACTER*32 :: EPISODE</CODE>
                <DD>Current modeling-episode name

                <DT><CODE>CHARACTER*32 :: SPONSOR</CODE>
                <DD>Current modeling-project sponsor's name

                <DT><CODE>CHARACTER*32 :: CMAQVERS</CODE>
                <DD>CMAQ model version

                <DT><CODE>CHARACTER*32 :: MCIPVERS</CODE>
                <DD>MCIP model version

                <DT><CODE>CHARACTER*32 :: EMISVERS</CODE>
                <DD>Current emissions model name and version

                <DT><CODE>CHARACTER*256 :: METVERS</CODE>
                <DD>Current meteorology-model name and version

                <DT><CODE>CHARACTER*256 :: CMAQCFG</CODE>
                <DD>CMAQ configuration (as text)

                <DT><CODE>CHARACTER*256 :: MCIPCFG</CODE>
                <DD>MCIP configuration (as text)

                <DT><CODE>CHARACTER*256 :: EMISCFG</CODE>
                <DD>Emissions-model configuration (as text)

                <DT><CODE>CHARACTER*256 :: ICBCCFG</CODE>
                <DD>IC/BC configuration (as text)

                <DT><CODE>CHARACTER*256 :: METCFG</CODE>
                <DD>Meteorology-model configuration (as text)

                <DT><CODE>REAL :: SYNC_TOP</CODE>
                <DD>Value of CMAQ environment variable <CODE>SIGMA_SYNC_TOP</CODE>:<BR>
                top sigma level thru which sync step determined

                <DT><CODE>INTEGER :: MAXSYNC</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_MAXSYNC</CODE>:<BR>
                max sync time step (sec)

                <DT><CODE>INTEGER :: MINSYNC</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_MINSYNC</CODE>:<BR>
                min sync time step (sec)

                <P>

                <EM>For the following,
                <BLOCKQUOTE>
                <CODE>1</CODE> represents <CODE>LOGICAL TRUE</CODE>
                <CODE>0</CODE> represents <CODE>LOGICAL FALSE</CODE>
                <CODE>IMISS3=-9999</CODE> represents &quot;Missing&quot;
                </BLOCKQUOTE></EM>

                <DT><CODE>INTEGER :: WB_DUST</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_WB_DUST</CODE>:<BR>
                Flag &quot;  use in-line wind-borne dust computation?&quot;

                <DT><CODE>INTEGER :: ERODE_AGLAND</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_ERODE_AGLAND</CODE>:<BR>
                Flag &quot; use in-line wind-borne dust computation?&quot;

                <DT><CODE>CHARACTER*8 :: WBDUST_BELD</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_WBDUST_BELD</CODE>:<BR>
                Flag &quot; landuse database for identifying dust source regions [ default: BELD3 ]&quot;

                <DT><CODE>INTEGER :: LTNG_NO</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_LTNG_NO</CODE>:<BR>
                Flag &quot; Is lighning NOx active?&quot;

                <DT><CODE>INTEGER :: KZMIN</CODE>
                <DD>Value of CMAQ environment variable <CODE>KZMIN</CODE>:<BR>
                Flag &quot; use Min Kz option in edyintb?&quot;

                <DT><CODE>INTEGER :: ILDEPV</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_ILDEPV</CODE>:<BR>
                Flag &quot; Is in-line deposition-velocity calculation active?&quot;

                <DT><CODE>INTEGER :: MOSAIC</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_MOSAIC</CODE>:<BR>
                Flag &quot; use landuse specific deposition velocities?&quot;

                <DT><CODE>INTEGER :: ABFLUX</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_ABFLUX</CODE>:<BR>
                Flag &quot; Use Ammonia bi-directional flux for in-line deposition velocities?&quot;

                <DT><CODE>INTEGER :: HGBIDI</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_HGBIDI</CODE>:<BR>
                Flag &quot; use Mercury bi-directional flux for in-line deposition velocities?&quot;

                <DT><CODE>INTEGER :: SFC_HONO</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_SFC_HONO</CODE>:<BR>
                Flag &quot; Use Surface HONO interaction in deposition velocities?&quot;

                <DT><CODE>INTEGER :: BIOGEMIS</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_BIOGEMIS</CODE>:<BR>
                Flag &quot; Are in-line biogenic emissions active?&quot;

                <DT><CODE>INTEGER :: PT3DEMIS</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_PT3DEMIS</CODE>:<BR>
                Flag &quot;  Is in-line plume rise active?&quot;

                <DT><CODE>INTEGER :: CLD_DIAG</CODE>
                <DD>Value of CMAQ environment variable <CODE>CLD_DIAG</CODE>:<BR>
                Flag &quot; write cloud diagnostic file?&quot;

                <DT><CODE>INTEGER :: AERDIAG</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_AERDIAG</CODE>:<BR>
                Flag &quot; write aerosol diagnostic file?&quot;

                <DT><CODE>INTEGER :: PHOTDIAG</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_PHOTDIAG</CODE>:<BR>
                Flag &quot; write photolysis diagnostic file?&quot;

                <DT><CODE>INTEGER :: SSEMDIAG</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_SSEMDIAG</CODE>:<BR>
                Flag &quot; write sea-salt emissions diagnostic file?&quot;

                <DT><CODE>INTEGER :: DUSTEM_DIAG</CODE>
                <DD>Value of CMAQ environment variable <CODE>CTM_DUSTEM_DIAG</CODE>:<BR>
                Flag &quot; write windblown dust emissions diagnostic file?&quot;

                <DT><CODE>INTEGER :: LTNGDIAG</CODE>
                <DD>Value of CMAQ environment variable <CODE>LTNGDIAG</CODE>:<BR>
                Flag &quot; write lightning diagnostic file?&quot;

                <DT><CODE>INTEGER :: B3GTS_DIAG</CODE>
                <DD>Value of CMAQ environment variable <CODE>B3GTS_DIAG</CODE>:<BR>
                Flag &quot; write beis mass emissions diagnostic file?&quot;

                <DT><CODE>INTEGER :: PT3DDIAG</CODE>
                <DD>Value of CMAQ environment variable <CODE>PT3DDIAG</CODE>:<BR>
                Flag &quot; write 3d point source emissions diagnostic file?&quot;

                <DT><CODE>INTEGER :: PT3DFRAC</CODE>
                <DD>Value of CMAQ environment variable <CODE>PT3DFRAC</CODE>:<BR>
                Flag &quot; write layer fractions diagnostic?&quot;

             </DL>
             <P>

        <DT> <CODE>TYPE SMETA_T</CODE>
        <DD> Derived data type for standard SMOKE metadata objects, if
             that ever happens (currently, only a dummy implementation).<BR>
             The fields are the following:
             <DL>
                <DT><CODE>INTEGER :: VERSION</CODE>
                <DD>Version-number for the SMOKE-metadata data dictionary
             </DL>
             <P>

        <DT> <CODE>TYPE( CMETA_T ), PUBLIC, PROTECTED :: CMAQ_MDATA</CODE>
        <DD> Module state-object for CMAQ metadata.  If <CODE>CMAQMETA</CODE>,
             holds standard CMAQ metadata.
             <P>

        <DT> <CODE>TYPE( SMETA_T ), PUBLIC, PROTECTED :: SMOKE_MDATA</CODE>
        <DD> Module state-object for SMOKE metadata.  If <CODE>SMOKEMETA</CODE>,
             holds standard SMOKE metadata.
             <P>
        <DT> &nbsp;

        <DT> <CODE>INTEGER, PARAMETER :: INGRD3</CODE>
        <DD> Token to use in matrix-attribute calls to indicate that the
             grid whose metadata is being accessed is an input grid for
             the matrix.
             <P>
        <DT> <CODE>INTEGER, PARAMETER :: OUTGRD3</CODE>
        <DD> Token to use in matrix-attribute calls to indicate that the
             grid whose metadata is being accessed is an output grid for the
             matrix.
             <P>
        <DT> &nbsp;
        <DT> <CODE><A HREF="#getmtxatt">GETMTXATT()</A></CODE>
        <DD> get input or output grid description attributes for
             matrix-files and return as arguments:<BR>
             <EM>Generic with forms for matrix-input-only, matrix-output-only,
             matrix-input-and-output metadata</EM>
             <P>
        <DT> <CODE><A HREF="#initmtxatt">INITMTXATT()</A></CODE>
        <DD> set state-variables for input and output grid description
             attributes for matrix-file.
             <P>
        <DT> <CODE><A HREF="#setmtxatt">SETMTXATT()</A></CODE>
        <DD> set or check input and output grid description attributes
             from arguments for matrix-files:  if file is NEW, set the
             attributes; else check them.  Retains these attributes
             in <CODE>PRIVATE</CODE> state-variables in the module.:<BR>
             <EM>Generic with forms for matrix-input-only, matrix-output-only,
             matrix-input-and-output metadata</EM>
             <P>
        <DT> <CODE><A HREF="#chkmtxatt">CHKMTXATT()</A></CODE>
        <DD> check input or output grid description attributes for
             matrix-files against attributes from  the argument list.
             Return <CODE>.TRUE.</CODE> if they match,
             <CODE>.FALSE.</CODE> otherwise.:<BR>
             <EM>Generic with forms for matrix-input-only, matrix-output-only,
             matrix-input-and-output metadata</EM>
             <P>
        <DT> <CODE><A HREF="#endmtxatt">ENDMTXATT()</A></CODE>
        <DD> turn off input and output grid description attributes
        from <CODE>INITMTXATT()</CODE> or <CODE>SETMTXATT()</CODE>
             <P>
        <DT> &nbsp;

        <DT> <CODE><A HREF="#initcf">INITCF()</A></CODE>
        <DD> turns on CF-metadata for all new files created
             <P>
        <DT> <CODE><A HREF="#setcf">SETCF()</A></CODE>
        <DD> writes CF-metadata for a specific file.
             <P>
        <DT> <CODE><A HREF="#endcf">ENDCF()</A></CODE>
        <DD> turns off writing CF metadata for new files created
             subsequently.
             <P>
        <DT> &nbsp;
        <DT> <CODE><A HREF="#initcmaq">INITCMAQ()</A></CODE>
        <DD> turns on CMAQ-metadata for all new files created
             <P>
        <DT> <CODE><A HREF="#getcmaq">GETCMAQ()</A></CODE>
        <DD> reads CMAQ-metadata from a specific file.
             <P>
        <DT> <CODE><A HREF="#logcmaq">LOGCMAQ()</A></CODE>
        <DD> print human readable CMAQ-metadata.
             <P>
        <DT> <CODE><A HREF="#setcmaq">SETCMAQ()</A></CODE>
        <DD> writes CMAQ-metadata for a specific file.
             <P>
        <DT> <CODE><A HREF="#endcmaq">ENDCMAQ()</A></CODE>
        <DD> turns off writing CMAQ metadata for new files created
             subsequently.
             <P>
        <DT> &nbsp;

        <DT> <CODE><A HREF="#initsmoke">INITSMOKE()</A></CODE>
        <DD> turns on SMOKE-metadata for all new files created
             <P>
        <DT> <CODE><A HREF="#getsmoke">GETSMOKE()</A></CODE>
        <DD> reads SMOKE-metadata from a specific file.
             <P>
        <DT> <CODE><A HREF="#setsmoke">SETSMOKE()</A></CODE>
        <DD> writes SMOKE-metadata for a specific file.
             <P>
        <DT> <CODE><A HREF="#endsmoke">ENDSMOKE()</A></CODE>
        <DD> turns off writing SMOKE metadata for new files created
             subsequently.
             <P>
        <P>
    </DL>

    </BLOCKQUOTE>

<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="initmtxatt"> INITMTXATT</A></H3>

    <PRE>
    SUBROUTINE  INITMTXATT(                                             &amp;
            GDNAM1, GDTYP1, P_ALP1, P_BET1, P_GAM1, XCENT1, YCENT1,     &amp;
                    XORIG1, YORIG1, XCELL1, YCELL1, NCOLS1, NROWS1,     &amp;
            GDNAM2, GDTYP2, P_ALP2, P_BET2, P_GAM2, XCENT2, YCENT2,     &amp;
                    XORIG2, YORIG2, XCELL2, YCELL2, NCOLS2, NROWS2 )

        CHARACTER( LEN=* ), INTENT( IN ) :: GDNAM1, GDNAM2
        INTEGER           , INTENT( IN ) :: GDTYP1, GDTYP2
        REAL*8            , INTENT( IN ) :: P_ALP1, P_ALP2
        REAL*8            , INTENT( IN ) :: P_BET1, P_BET2
        REAL*8            , INTENT( IN ) :: P_GAM1, P_GAM2
        REAL*8            , INTENT( IN ) :: XCENT1, XCENT2
        REAL*8            , INTENT( IN ) :: YCENT1, YCENT2
        REAL*8            , INTENT( IN ) :: XORIG1, XORIG2
        REAL*8            , INTENT( IN ) :: YORIG1, YORIG2
        REAL*8            , INTENT( IN ) :: XCELL1, XCELL2
        REAL*8            , INTENT( IN ) :: YCELL1, YCELL2
        INTEGER           , INTENT( IN ) :: NCOLS1, NCOLS2
        INTEGER           , INTENT( IN ) :: NROWS1, NROWS2
    </PRE>

    The first set of arguments
    <CODE>GDNAM1</CODE>&nbsp;...&nbsp;<CODE>NROWS1</CODE> are for the
    matrix-input grid;  the last set of arguments
    <CODE>GDNAM2</CODE>&nbsp;...&nbsp;<CODE>NROWS2</CODE> for the
    matrix-output grid.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="getmtxatt"> GETMTXATT</A></H3>

    <PRE>
    GENERIC INTERFACE:
    LOGICAL FUNCTION  GETMTXATT( FNAME, IMODE, GDNAM,                       &amp;
                                 GDTYP, P_ALP, P_BET, P_GAM, XCENT, YCENT,  &amp;
                                 XORIG, YORIG, XCELL, YCELL, NCOLS, NROWS )

        CHARACTER( LEN=* ), INTENT(  IN ):: FNAME  !! logical file name
        INTEGER           , INTENT(  IN ):: IMODE  !! INGRD3 or OUTGRD3
        CHARACTER( LEN=* ), INTENT( OUT ):: GDNAM  !! grid name
        INTEGER           , INTENT( OUT ):: GDTYP  !! map projection type
        REAL*8            , INTENT( OUT ):: P_ALP  !! map projection parameters...
        REAL*8            , INTENT( OUT ):: P_BET  !!  "
        REAL*8            , INTENT( OUT ):: P_GAM  !!  "
        REAL*8            , INTENT( OUT ):: XCENT  !!  "
        REAL*8            , INTENT( OUT ):: YCENT  !!  "
        REAL*8            , INTENT( OUT ):: XORIG  !! Grid origin
        REAL*8            , INTENT( OUT ):: YORIG  !!  "
        REAL*8            , INTENT( OUT ):: XCELL  !! Grid cell-size
        REAL*8            , INTENT( OUT ):: YCELL  !!  "
        INTEGER           , INTENT( OUT ):: NCOLS  !! Grid dimension
        INTEGER           , INTENT( OUT ):: NROWS  !!  "

    LOGICAL FUNCTION  GETMTXATT( FNAME,                                 &amp;
            GDNAM1, GDTYP1, P_ALP1, P_BET1, P_GAM1, XCENT1, YCENT1,     &amp;
                    XORIG1, YORIG1, XCELL1, YCELL1, NCOLS1, NROWS1,     &amp;
            GDNAM2, GDTYP2, P_ALP2, P_BET2, P_GAM2, XCENT2, YCENT2,     &amp;
                    XORIG2, YORIG2, XCELL2, YCELL2, NCOLS2, NROWS2 )

        CHARACTER( LEN=* ), INTENT(IN   ) :: FNAME
        CHARACTER( LEN=* ), INTENT(  OUT) :: GDNAM1, GDNAM2
        INTEGER           , INTENT(  OUT) :: GDTYP1, GDTYP2
        REAL*8            , INTENT(  OUT) :: P_ALP1, P_ALP2
        REAL*8            , INTENT(  OUT) :: P_BET1, P_BET2
        REAL*8            , INTENT(  OUT) :: P_GAM1, P_GAM2
        REAL*8            , INTENT(  OUT) :: XCENT1, XCENT2
        REAL*8            , INTENT(  OUT) :: YCENT1, YCENT2
        REAL*8            , INTENT(  OUT) :: XORIG1, XORIG2
        REAL*8            , INTENT(  OUT) :: YORIG1, YORIG2
        REAL*8            , INTENT(  OUT) :: XCELL1, XCELL2
        REAL*8            , INTENT(  OUT) :: YCELL1, YCELL2
        INTEGER           , INTENT(  OUT) :: NCOLS1, NCOLS2
        INTEGER           , INTENT(  OUT) :: NROWS1, NROWS2
    </PRE>

    <CODE>GDNAM1</CODE> ... <CODE>NROWS1</CODE> are for the matrix-input
    grid;  <CODE>GDNAM2</CODE> ... <CODE>NROWS2</CODE> for the
    matrix-output grid.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="setmtxatt">SETMTXATT</A></H3>

    <PRE>
    GENERIC INTERFACE:
    LOGICAL FUNCTION  SETMTXATT( FNAME, IMODE, GDNAM,                       &amp;
                                 GDTYP, P_ALP, P_BET, P_GAM, XCENT, YCENT,  &amp;
                                 XORIG, YORIG, XCELL, YCELL, NCOLS, NROWS )

        CHARACTER( LEN=* ), INTENT( IN ):: FNAME  !! logical file name
        INTEGER           , INTENT( IN ):: IMODE  !! INGRD3 or OUTGRD3
        CHARACTER( LEN=* ), INTENT( IN ):: GDNAM  !! grid name
        INTEGER           , INTENT( IN ):: GDTYP  !! map projection type
        REAL*8            , INTENT( IN ):: P_ALP  !! map projection parameters...
        REAL*8            , INTENT( IN ):: P_BET  !!  "
        REAL*8            , INTENT( IN ):: P_GAM  !!  "
        REAL*8            , INTENT( IN ):: XCENT  !!  "
        REAL*8            , INTENT( IN ):: YCENT  !!  "
        REAL*8            , INTENT( IN ):: XORIG  !! Grid origin
        REAL*8            , INTENT( IN ):: YORIG  !!  "
        REAL*8            , INTENT( IN ):: XCELL  !! Grid cell-size
        REAL*8            , INTENT( IN ):: YCELL  !!  "
        INTEGER           , INTENT( IN ):: NCOLS  !! Grid dimension
        INTEGER           , INTENT( IN ):: NROWS  !!  "

    LOGICAL FUNCTION  SETMTXATT( FNAME,                                 &amp;
            GDNAM1, GDTYP1, P_ALP1, P_BET1, P_GAM1, XCENT1, YCENT1,     &amp;
                    XORIG1, YORIG1, XCELL1, YCELL1, NCOLS1, NROWS1,     &amp;
            GDNAM2, GDTYP2, P_ALP2, P_BET2, P_GAM2, XCENT2, YCENT2,     &amp;
                    XORIG2, YORIG2, XCELL2, YCELL2, NCOLS2, NROWS2 )

        CHARACTER( LEN=* ), INTENT( IN ) :: FNAME
        CHARACTER( LEN=* ), INTENT( IN ) :: GDNAM1, GDNAM2
        INTEGER           , INTENT( IN ) :: GDTYP1, GDTYP2
        REAL*8            , INTENT( IN ) :: P_ALP1, P_ALP2
        REAL*8            , INTENT( IN ) :: P_BET1, P_BET2
        REAL*8            , INTENT( IN ) :: P_GAM1, P_GAM2
        REAL*8            , INTENT( IN ) :: XCENT1, XCENT2
        REAL*8            , INTENT( IN ) :: YCENT1, YCENT2
        REAL*8            , INTENT( IN ) :: XORIG1, XORIG2
        REAL*8            , INTENT( IN ) :: YORIG1, YORIG2
        REAL*8            , INTENT( IN ) :: XCELL1, XCELL2
        REAL*8            , INTENT( IN ) :: YCELL1, YCELL2
        INTEGER           , INTENT( IN ) :: NCOLS1, NCOLS2
        INTEGER           , INTENT( IN ) :: NROWS1, NROWS2

    LOGICAL FUNCTION  SETMTXATT3( FNAME )

        CHARACTER( LEN=* ), INTENT( IN ) :: FNAME
    </PRE>

    <CODE>GDNAM1</CODE> ... <CODE>NROWS1</CODE> are for the matrix-input
    grid;  <CODE>GDNAM2</CODE> ... <CODE>NROWS2</CODE> for the
    matrix-output grid.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="chkmtxatt">CHKMTXATT</A></H3>

    <PRE>
    GENERIC INTERFACE:
    LOGICAL FUNCTION  CHKMTXATT( FNAME, IMODE, GDNAM,                          &amp;
                                 GDTYP, P_ALP, P_BET, P_GAM, XCENT, YCENT,     &amp;
                                 XORIG, YORIG, XCELL, YCELL, NCOLS, NROWS )

        CHARACTER( LEN=* ), INTENT( IN ):: FNAME  !! logical file name
        INTEGER           , INTENT( IN ):: IMODE  !! INGRD3 or OUTGRD3
        CHARACTER( LEN=* ), INTENT( IN ):: GDNAM  !! grid name
        INTEGER           , INTENT( IN ):: GDTYP  !! map projection type
        REAL*8            , INTENT( IN ):: P_ALP  !! map projection parameters...
        REAL*8            , INTENT( IN ):: P_BET  !!  "
        REAL*8            , INTENT( IN ):: P_GAM  !!  "
        REAL*8            , INTENT( IN ):: XCENT  !!  "
        REAL*8            , INTENT( IN ):: YCENT  !!  "
        REAL*8            , INTENT( IN ):: XORIG  !! Grid origin
        REAL*8            , INTENT( IN ):: YORIG  !!  "
        REAL*8            , INTENT( IN ):: XCELL  !! Grid cell-size
        REAL*8            , INTENT( IN ):: YCELL  !!  "
        INTEGER           , INTENT( IN ):: NCOLS  !! Grid dimension
        INTEGER           , INTENT( IN ):: NROWS  !!  "

    LOGICAL FUNCTION  CHKMTXATT( FNAME,                             &amp;
           GDNAM1, GDTYP1, P_ALP1, P_BET1, P_GAM1, XCENT1, YCENT1,  &amp;
                   XORIG1, YORIG1, XCELL1, YCELL1, NCOLS1, NROWS1,  &amp;
           GDNAM2, GDTYP2, P_ALP2, P_BET2, P_GAM2, XCENT2, YCENT2,  &amp;
                   XORIG2, YORIG2, XCELL2, YCELL2, NCOLS2, NROWS2 )

        CHARACTER( LEN=* ), INTENT(IN   ) :: FNAME
        CHARACTER( LEN=* ), INTENT(IN   ) :: GDNAM1, GDNAM2
        INTEGER           , INTENT(IN   ) :: GDTYP1, GDTYP2
        REAL*8            , INTENT(IN   ) :: P_ALP1, P_ALP2
        REAL*8            , INTENT(IN   ) :: P_BET1, P_BET2
        REAL*8            , INTENT(IN   ) :: P_GAM1, P_GAM2
        REAL*8            , INTENT(IN   ) :: XCENT1, XCENT2
        REAL*8            , INTENT(IN   ) :: YCENT1, YCENT2
        REAL*8            , INTENT(IN   ) :: XORIG1, XORIG2
        REAL*8            , INTENT(IN   ) :: YORIG1, YORIG2
        REAL*8            , INTENT(IN   ) :: XCELL1, XCELL2
        REAL*8            , INTENT(IN   ) :: YCELL1, YCELL2
        INTEGER           , INTENT(IN   ) :: NCOLS1, NCOLS2
        INTEGER           , INTENT(IN   ) :: NROWS1, NROWS2

    LOGICAL FUNCTION  CHKMTXATT3( FNAME )

        CHARACTER( LEN=* ), INTENT( IN ):: FNAME

    </PRE>

    <CODE>GDNAM1</CODE> ... <CODE>NROWS1</CODE> are for the matrix-input
    grid;  <CODE>GDNAM2</CODE> ... <CODE>NROWS2</CODE> for the
    matrix-output grid.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="endmtxatt">ENDMTXATT</A></H3>

    <PRE>
    LOGICAL FUNCTION  ENDMTXATT( )
    </PRE>

    Turns off input and output grid description attributes
    from <CODE>INITMTXATT()</CODE> or <CODE>SETMTXATT()</CODE>:
    sets <CODE>MATXMETA&nbsp;=&nbsp;.FALSE.</CODE>.

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="initcf">INITCF</A></H3>

    <PRE>
    SUBROUTINE  INITCF()
    </PRE>

    Turns on writing CF-compliant metadata for all new I/O&nbsp;API
    files subsequently created by the calling program.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="setcf">SETCF</A></H3>

    <PRE>
    GENERIC INTERFACE:
    SUBROUTINE  SETCF( FNAME )
    SUBROUTINE  SETCF( FID )

        CHARACTER( LEN=* ), INTENT( IN ) :: FNAME
        INTEGER           , INTENT( IN ) :: FID
    </PRE>

    <CODE>FNAME</CODE> must be the logical name of an I/O&nbsp;API
    file currently open for output, or else <CODE>FID</CODE> must be the
    internal file-index for a file currently being opened for output.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="endcf">ENDCF</A></H3>

    <PRE>
    SUBROUTINE  ENDCF()
    </PRE>

    Turns off writing CF-compliant metadata for new I/O&nbsp;API
    files subsequently opened by the calling program:
    sets <CODE>CFMETA&nbsp;=&nbsp;.FALSE.</CODE>.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->


<H3> <A NAME="initcmaq">INITCMAQ</A></H3>

    <PRE>
    GENERIC INTERFACE:
    LOGICAL FUNCTION  INITCMAQ()
    LOGICAL FUNCTION  INITCMAQ( MDATA )

        TYPE(CMETA_T) , INTENT( IN ) :: MDATA
    </PRE>

    Initializes internal state variables holding CMAQ-standard metadata
    from either the standard-format text file with logical name
    <CODE>IOAPI_CMAQMETA</CODE>, from the program-environment if
    <CODE>IOAPI_CMAQMETA=="ENV"</CODE> or from the argument <CODE>MDATA</CODE>.
    <P>
    <CODE>IOAPI_CMAQMETA</CODE> should be either <CODE>NONE</CODE> to
    turn off CMAQ metadata (the default), or the path for a
    structured-ASCII file with format [TBD].
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="getcmaq">GETCMAQ</A></H3>

    <PRE>
    GENERIC INTERFACE:
    LOGICAL FUNCTION  GETCMAQ( FNAME )
    LOGICAL FUNCTION  GETCMAQ( FNAME, MDATA )

        CHARACTER( LEN=* ), INTENT( IN ) :: FNAME
        TYPE(CMETA_T)     , INTENT( IN ) :: MDATA
    </PRE>

    Reads CMAQ-standard metadata from the header of file
    <CODE>FNAME</CODE> and puts it either into CMAQ-metadata object
    <CODE>MDATA</CODE> (if present) or into CMAQ-metadata module
    variable <CODE>CMAQ_MDATA</CODE>.  If successful, sets
    <CODE>CMAQMETA</CODE> to <CODE>TRUE</CODE>.
    <P>

    <CODE>FNAME</CODE> must be the logical name of an I/O&nbsp;API
    file currently open for input.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="logcmaq">LOGCMAQ</A></H3>

    <PRE>
    GENERIC INTERFACE:
    LOGICAL FUNCTION  LOGCMAQ(  )
    LOGICAL FUNCTION  LOGCMAQ( FNAME )
    LOGICAL FUNCTION  LOGCMAQ( MDATA )
    LOGICAL FUNCTION  LOGCMAQ( FNAME, MDATA )

        CHARACTER(LEN=*), INTENT( IN ) :: FNAME
        TYPE(CMETA_T)   , INTENT( IN ) :: MDATA
    </PRE>

    Writes CMAQ-standard metadata either from metadata-object
    <CODE>MDATA</CODE> (if present) or CMAQ-metadata module variable
    <CODE>CMAQ_MDATA</CODE> (otherwise) either to a structured-ASCII
    output file <CODE>FNAME</CODE> (if present) or to the program log
    (otherwise).
    <P>

    If present, <CODE>FNAME</CODE> must be the logical name for the
    structured-ASCII output file.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="setcmaq">SETCMAQ</A></H3>

    <PRE>
    GENERIC INTERFACE:
    LOGICAL FUNCTION  SETCMAQ( FID )
    LOGICAL FUNCTION  SETCMAQ( FNAME )
    LOGICAL FUNCTION  SETCMAQ( FNAME, MDATA )

        INTEGER           , INTENT( IN ) :: FID
        CHARACTER( LEN=* ), INTENT( IN ) :: FNAME
        TYPE(CMETA_T)     , INTENT( IN ) :: MDATA
    </PRE>

    Writes CMAQ-standard metadata either from metadata-object
    <CODE>MDATA</CODE> (if available) or CMAQ-metadata module variable
    <CODE>CMAQ_MDATA</CODE> (otherwise) to the header of I/O&nbsp;API
    file with either logical name <CODE>FNAME</CODE> or
    <CODE>STATE3</CODE> file-index <CODE>FID</CODE>.<BR>
    <EM>NOTE:  the last two forms are the ones intended for
    modeler-use; the first should be considered as internal
    to the I/O&nbsp;API, and is the one called automatically.</EM>
    <P>
    If <CODE>IOAPI_CMAQMETA</CODE> is not <CODE>NONE</CODE>, the first
    form is called automatically as part of the file-creation process.
    <P>
    PRECONDITION:   <CODE>FNAME</CODE> must be the logical name of an
    I/O&nbsp;API file being opened or currently open for output.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="endcmaq">ENDCMAQ</A></H3>

    <PRE>
    SUBROUTINE  ENDCMAQ()
    </PRE>

    Turns off CMAQ-standard metadata:
    sets <CODE>CMAQMETA&nbsp;=&nbsp;.FALSE.</CODE>.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->


<H3> <A NAME="initsmoke">INITSMOKE</A></H3>

    <PRE>
    GENERIC INTERFACE:
    LOGICAL FUNCTION  INITSMOKE( )
    LOGICAL FUNCTION  INITSMOKE( MDATA )

        TYPE(SMETA_T)     , INTENT( IN ) :: MDATA
    </PRE>

    Initializes internal state variables holding SMOKE-standard metadata.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="getsmoke">GETSMOKE</A></H3>

    <PRE>
    GENERIC INTERFACE:
    LOGICAL FUNCTION  GETSMOKE( FNAME )
    LOGICAL FUNCTION  GETSMOKE( FNAME, MDATA )

        CHARACTER(LEN=*), INTENT( IN ) :: FNAME
        TYPE(SMETA_T)   , INTENT( IN ) :: MDATA
    </PRE>

    Reads SMOKE-standard metadata from the header of file
    <CODE>FNAME</CODE> and puts it either into SMOKE-metadata object
    <CODE>MDATA</CODE> or into SMOKE-metadata module variable
    <CODE>SMOKE_MDATA</CODE>.  If successful, sets <CODE>SMOKEMETA</CODE>
    to TRUE.
    <P>

    <CODE>FNAME</CODE> must be the logical name of an I/O&nbsp;API
    file currently open for input.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="setsmoke">SETSMOKE</A></H3>

    <PRE>
    GENERIC INTERFACE:
    LOGICAL FUNCTION  SETSMOKE( FID )
    LOGICAL FUNCTION  SETSMOKE( FNAME )
    LOGICAL FUNCTION  SETSMOKE( FNAME, MDATA )

        INTEGER           , INTENT( IN ) :: FID
        CHARACTER( LEN=* ), INTENT( IN ) :: FNAME
        TYPE(SMETA_T)     , INTENT( IN ) :: MDATA
    </PRE>

    Writes SMOKE-standard metadata either from metadata-object
    <CODE>MDATA</CODE> (if available) or SMOKE-metadata module variable
    <CODE>SMOKE_MDATA</CODE> (otherwise) to the header of I/O&nbsp;API file
    with either logical name <CODE>FNAME</CODE> or file-index
    <CODE>FID</CODE>.<BR>
    <EM>NOTE:  the last two forms are the ones intended for
    modeler-use; the first should be considered as internal
    to the I/O API, and is the one called automatically.</EM>
    <P>
    If <CODE>SMOKEMETA</CODE>> is <CODE>TRUE</CODE>, the first form is
    called automatically as part of the file-creation process.
    <P>
    PRECONDITION:   <CODE>FNAME</CODE> must be the logical name of an
    I/O&nbsp;API file being opened or currently open for output.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<H3> <A NAME="endsmoke">ENDSMOKE</A></H3>

    <PRE>
    SUBROUTINE  ENDSMOKE()
    </PRE>

    Turns off SMOKE-standard metadata:
    sets <CODE>SMOKEMETA&nbsp;=&nbsp;.FALSE.</CODE>.
    <P>

    Back to <STRONG><EM><A HREF = "#contents">Contents</A></EM></STRONG>
    <P>


<HR> <!- ------------------------------------------------------------- ->

<A HREF = "AA.html">
To: <STRONG>Models-3/EDSS I/O API:   The Help Pages</STRONG>
</A><P>


Send comments to
<A HREF = "mailto:cjcoats@email.unc.edu"> <ADDRESS>
          Carlie J. Coats, Jr. <br>
          cjcoats@email.unc.edu  </ADDRESS> </A><P>

<!--#include virtual="/INCLUDES/footer.html" -->


</BODY>
</HTML>

